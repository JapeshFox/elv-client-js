

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="shortcut icon" href="images/favicon.png" >

  <title>
    ElvClient.js - Documentation
  </title>

  <script src="scripts/prettify/prettify.js"></script>
  <script src="scripts/prettify/lang-css.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/elv-jsdoc.css">
  <link type="text/css" rel="stylesheet" href="styles/elv-prettify-jsdoc.css">
</head>

<body>
  <div class="layout-container">
    <nav class="nav-container">
      <div class="header">
        <a href="index.html">
          <img class="logo" src="images/logo-dark.png" />
        </a>
        <div class="title">
          Eluvio Javascript Client
        </div>
      </div>
      <div class="nav-content">
        <h3>Classes</h3><ul><li id="ElvClient-nav">
          <div data-name="ElvClient" class="class-link-container"><a class="class-link">ElvClient</a></div><ul class='methods'><h4 class="methodGroupHeader">Constructor</h4><li data-type="method" id="ElvClient-ElvClient-nav"><a href="ElvClient.html" class="method-link">ElvClient</a></li><li data-type="method" id="ElvClient-Configuration-nav"><a href="ElvClient.html#.Configuration" class="method-link">Configuration</a></li><li data-type="method" id="ElvClient-FromConfigurationUrl-nav"><a href="ElvClient.html#.FromConfigurationUrl" class="method-link">FromConfigurationUrl</a></li><h4 class="methodGroupHeader">Access Groups</h4><li data-type="method" id="ElvClient-AccessGroupOwner-nav"><a href="ElvClient.html#AccessGroupOwner" class="method-link">AccessGroupOwner</a></li><li data-type="method" id="ElvClient-AddAccessGroupManager-nav"><a href="ElvClient.html#AddAccessGroupManager" class="method-link">AddAccessGroupManager</a></li><li data-type="method" id="ElvClient-AddAccessGroupMember-nav"><a href="ElvClient.html#AddAccessGroupMember" class="method-link">AddAccessGroupMember</a></li><li data-type="method" id="ElvClient-AddContentLibraryGroup-nav"><a href="ElvClient.html#AddContentLibraryGroup" class="method-link">AddContentLibraryGroup</a></li><li data-type="method" id="ElvClient-AddContentObjectGroupPermission-nav"><a href="ElvClient.html#AddContentObjectGroupPermission" class="method-link">AddContentObjectGroupPermission</a></li><li data-type="method" id="ElvClient-ContentLibraryGroupPermissions-nav"><a href="ElvClient.html#ContentLibraryGroupPermissions" class="method-link">ContentLibraryGroupPermissions</a></li><li data-type="method" id="ElvClient-ContentObjectGroupPermissions-nav"><a href="ElvClient.html#ContentObjectGroupPermissions" class="method-link">ContentObjectGroupPermissions</a></li><li data-type="method" id="ElvClient-CreateAccessGroup-nav"><a href="ElvClient.html#CreateAccessGroup" class="method-link">CreateAccessGroup</a></li><li data-type="method" id="ElvClient-DeleteAccessGroup-nav"><a href="ElvClient.html#DeleteAccessGroup" class="method-link">DeleteAccessGroup</a></li><li data-type="method" id="ElvClient-RemoveAccessGroupManager-nav"><a href="ElvClient.html#RemoveAccessGroupManager" class="method-link">RemoveAccessGroupManager</a></li><li data-type="method" id="ElvClient-RemoveAccessGroupMember-nav"><a href="ElvClient.html#RemoveAccessGroupMember" class="method-link">RemoveAccessGroupMember</a></li><li data-type="method" id="ElvClient-RemoveContentLibraryGroup-nav"><a href="ElvClient.html#RemoveContentLibraryGroup" class="method-link">RemoveContentLibraryGroup</a></li><li data-type="method" id="ElvClient-RemoveContentObjectGroupPermission-nav"><a href="ElvClient.html#RemoveContentObjectGroupPermission" class="method-link">RemoveContentObjectGroupPermission</a></li><h4 class="methodGroupHeader">Access Requests</h4><li data-type="method" id="ElvClient-AccessInfo-nav"><a href="ElvClient.html#AccessInfo" class="method-link">AccessInfo</a></li><li data-type="method" id="ElvClient-AccessRequest-nav"><a href="ElvClient.html#AccessRequest" class="method-link">AccessRequest</a></li><li data-type="method" id="ElvClient-AccessType-nav"><a href="ElvClient.html#AccessType" class="method-link">AccessType</a></li><li data-type="method" id="ElvClient-CachedAccessTransaction-nav"><a href="ElvClient.html#CachedAccessTransaction" class="method-link">CachedAccessTransaction</a></li><li data-type="method" id="ElvClient-ClearCache-nav"><a href="ElvClient.html#ClearCache" class="method-link">ClearCache</a></li><li data-type="method" id="ElvClient-ContentObjectAccessComplete-nav"><a href="ElvClient.html#ContentObjectAccessComplete" class="method-link">ContentObjectAccessComplete</a></li><li data-type="method" id="ElvClient-FinalizeStateChannelAccess-nav"><a href="ElvClient.html#FinalizeStateChannelAccess" class="method-link">FinalizeStateChannelAccess</a></li><li data-type="method" id="ElvClient-GenerateStateChannelToken-nav"><a href="ElvClient.html#GenerateStateChannelToken" class="method-link">GenerateStateChannelToken</a></li><li data-type="method" id="ElvClient-SetAccessCharge-nav"><a href="ElvClient.html#SetAccessCharge" class="method-link">SetAccessCharge</a></li><h4 class="methodGroupHeader">AccessGroups</h4><li data-type="method" id="ElvClient-AccessGroupManagers-nav"><a href="ElvClient.html#AccessGroupManagers" class="method-link">AccessGroupManagers</a></li><li data-type="method" id="ElvClient-AccessGroupMembers-nav"><a href="ElvClient.html#AccessGroupMembers" class="method-link">AccessGroupMembers</a></li><h4 class="methodGroupHeader">Collections</h4><li data-type="method" id="ElvClient-Collection-nav"><a href="ElvClient.html#Collection" class="method-link">Collection</a></li><h4 class="methodGroupHeader">Content Libraries</h4><li data-type="method" id="ElvClient-AddLibraryContentType-nav"><a href="ElvClient.html#AddLibraryContentType" class="method-link">AddLibraryContentType</a></li><li data-type="method" id="ElvClient-ContentLibraries-nav"><a href="ElvClient.html#ContentLibraries" class="method-link">ContentLibraries</a></li><li data-type="method" id="ElvClient-ContentLibrary-nav"><a href="ElvClient.html#ContentLibrary" class="method-link">ContentLibrary</a></li><li data-type="method" id="ElvClient-ContentLibraryOwner-nav"><a href="ElvClient.html#ContentLibraryOwner" class="method-link">ContentLibraryOwner</a></li><li data-type="method" id="ElvClient-CreateContentLibrary-nav"><a href="ElvClient.html#CreateContentLibrary" class="method-link">CreateContentLibrary</a></li><li data-type="method" id="ElvClient-DeleteContentLibrary-nav"><a href="ElvClient.html#DeleteContentLibrary" class="method-link">DeleteContentLibrary</a></li><li data-type="method" id="ElvClient-LibraryContentTypes-nav"><a href="ElvClient.html#LibraryContentTypes" class="method-link">LibraryContentTypes</a></li><li data-type="method" id="ElvClient-RemoveLibraryContentType-nav"><a href="ElvClient.html#RemoveLibraryContentType" class="method-link">RemoveLibraryContentType</a></li><li data-type="method" id="ElvClient-SetContentLibraryImage-nav"><a href="ElvClient.html#SetContentLibraryImage" class="method-link">SetContentLibraryImage</a></li><h4 class="methodGroupHeader">Content Objects</h4><li data-type="method" id="ElvClient-ContentObject-nav"><a href="ElvClient.html#ContentObject" class="method-link">ContentObject</a></li><li data-type="method" id="ElvClient-ContentObjectLibraryId-nav"><a href="ElvClient.html#ContentObjectLibraryId" class="method-link">ContentObjectLibraryId</a></li><li data-type="method" id="ElvClient-ContentObjectOwner-nav"><a href="ElvClient.html#ContentObjectOwner" class="method-link">ContentObjectOwner</a></li><li data-type="method" id="ElvClient-ContentObjects-nav"><a href="ElvClient.html#ContentObjects" class="method-link">ContentObjects</a></li><li data-type="method" id="ElvClient-ContentObjectVersions-nav"><a href="ElvClient.html#ContentObjectVersions" class="method-link">ContentObjectVersions</a></li><li data-type="method" id="ElvClient-CopyContentObject-nav"><a href="ElvClient.html#CopyContentObject" class="method-link">CopyContentObject</a></li><li data-type="method" id="ElvClient-CreateContentObject-nav"><a href="ElvClient.html#CreateContentObject" class="method-link">CreateContentObject</a></li><li data-type="method" id="ElvClient-CustomContractAddress-nav"><a href="ElvClient.html#CustomContractAddress" class="method-link">CustomContractAddress</a></li><li data-type="method" id="ElvClient-DeleteContentObject-nav"><a href="ElvClient.html#DeleteContentObject" class="method-link">DeleteContentObject</a></li><li data-type="method" id="ElvClient-DeleteContentVersion-nav"><a href="ElvClient.html#DeleteContentVersion" class="method-link">DeleteContentVersion</a></li><li data-type="method" id="ElvClient-EditContentObject-nav"><a href="ElvClient.html#EditContentObject" class="method-link">EditContentObject</a></li><li data-type="method" id="ElvClient-FinalizeContentObject-nav"><a href="ElvClient.html#FinalizeContentObject" class="method-link">FinalizeContentObject</a></li><li data-type="method" id="ElvClient-LatestVersionHash-nav"><a href="ElvClient.html#LatestVersionHash" class="method-link">LatestVersionHash</a></li><li data-type="method" id="ElvClient-Proofs-nav"><a href="ElvClient.html#Proofs" class="method-link">Proofs</a></li><li data-type="method" id="ElvClient-PublishContentVersion-nav"><a href="ElvClient.html#PublishContentVersion" class="method-link">PublishContentVersion</a></li><li data-type="method" id="ElvClient-QParts-nav"><a href="ElvClient.html#QParts" class="method-link">QParts</a></li><li data-type="method" id="ElvClient-SetContentObjectImage-nav"><a href="ElvClient.html#SetContentObjectImage" class="method-link">SetContentObjectImage</a></li><li data-type="method" id="ElvClient-VerifyContentObject-nav"><a href="ElvClient.html#VerifyContentObject" class="method-link">VerifyContentObject</a></li><h4 class="methodGroupHeader">Content Space</h4><li data-type="method" id="ElvClient-ContentSpaceId-nav"><a href="ElvClient.html#ContentSpaceId" class="method-link">ContentSpaceId</a></li><li data-type="method" id="ElvClient-DefaultKMSAddress-nav"><a href="ElvClient.html#DefaultKMSAddress" class="method-link">DefaultKMSAddress</a></li><h4 class="methodGroupHeader">Content Types</h4><li data-type="method" id="ElvClient-ContentType-nav"><a href="ElvClient.html#ContentType" class="method-link">ContentType</a></li><li data-type="method" id="ElvClient-ContentTypeOwner-nav"><a href="ElvClient.html#ContentTypeOwner" class="method-link">ContentTypeOwner</a></li><li data-type="method" id="ElvClient-ContentTypes-nav"><a href="ElvClient.html#ContentTypes" class="method-link">ContentTypes</a></li><li data-type="method" id="ElvClient-CreateContentType-nav"><a href="ElvClient.html#CreateContentType" class="method-link">CreateContentType</a></li><h4 class="methodGroupHeader">Contracts</h4><li data-type="method" id="ElvClient-CallContractMethod-nav"><a href="ElvClient.html#CallContractMethod" class="method-link">CallContractMethod</a></li><li data-type="method" id="ElvClient-CallContractMethodAndWait-nav"><a href="ElvClient.html#CallContractMethodAndWait" class="method-link">CallContractMethodAndWait</a></li><li data-type="method" id="ElvClient-ContractEvents-nav"><a href="ElvClient.html#ContractEvents" class="method-link">ContractEvents</a></li><li data-type="method" id="ElvClient-ContractName-nav"><a href="ElvClient.html#ContractName" class="method-link">ContractName</a></li><li data-type="method" id="ElvClient-DeployContract-nav"><a href="ElvClient.html#DeployContract" class="method-link">DeployContract</a></li><li data-type="method" id="ElvClient-Events-nav"><a href="ElvClient.html#Events" class="method-link">Events</a></li><li data-type="method" id="ElvClient-ExtractEventFromLogs-nav"><a href="ElvClient.html#ExtractEventFromLogs" class="method-link">ExtractEventFromLogs</a></li><li data-type="method" id="ElvClient-ExtractValueFromEvent-nav"><a href="ElvClient.html#ExtractValueFromEvent" class="method-link">ExtractValueFromEvent</a></li><li data-type="method" id="ElvClient-FormatContractArguments-nav"><a href="ElvClient.html#FormatContractArguments" class="method-link">FormatContractArguments</a></li><li data-type="method" id="ElvClient-SetCustomContentContract-nav"><a href="ElvClient.html#SetCustomContentContract" class="method-link">SetCustomContentContract</a></li><h4 class="methodGroupHeader">Encryption</h4><li data-type="method" id="ElvClient-Decrypt-nav"><a href="ElvClient.html#Decrypt" class="method-link">Decrypt</a></li><li data-type="method" id="ElvClient-Encrypt-nav"><a href="ElvClient.html#Encrypt" class="method-link">Encrypt</a></li><li data-type="method" id="ElvClient-EncryptionConk-nav"><a href="ElvClient.html#EncryptionConk" class="method-link">EncryptionConk</a></li><h4 class="methodGroupHeader">Links</h4><li data-type="method" id="ElvClient-ContentObjectGraph-nav"><a href="ElvClient.html#ContentObjectGraph" class="method-link">ContentObjectGraph</a></li><li data-type="method" id="ElvClient-CreateLinks-nav"><a href="ElvClient.html#CreateLinks" class="method-link">CreateLinks</a></li><li data-type="method" id="ElvClient-LinkData-nav"><a href="ElvClient.html#LinkData" class="method-link">LinkData</a></li><li data-type="method" id="ElvClient-LinkTarget-nav"><a href="ElvClient.html#LinkTarget" class="method-link">LinkTarget</a></li><li data-type="method" id="ElvClient-LinkUrl-nav"><a href="ElvClient.html#LinkUrl" class="method-link">LinkUrl</a></li><h4 class="methodGroupHeader">Media</h4><li data-type="method" id="ElvClient-AvailableDRMs-nav"><a href="ElvClient.html#AvailableDRMs" class="method-link">AvailableDRMs</a></li><li data-type="method" id="ElvClient-BitmovinPlayoutOptions-nav"><a href="ElvClient.html#BitmovinPlayoutOptions" class="method-link">BitmovinPlayoutOptions</a></li><li data-type="method" id="ElvClient-CreateABRMezzanine-nav"><a href="ElvClient.html#CreateABRMezzanine" class="method-link">CreateABRMezzanine</a></li><li data-type="method" id="ElvClient-CreateProductionMaster-nav"><a href="ElvClient.html#CreateProductionMaster" class="method-link">CreateProductionMaster</a></li><li data-type="method" id="ElvClient-FinalizeABRMezzanine-nav"><a href="ElvClient.html#FinalizeABRMezzanine" class="method-link">FinalizeABRMezzanine</a></li><li data-type="method" id="ElvClient-LROStatus-nav"><a href="ElvClient.html#LROStatus" class="method-link">LROStatus</a></li><li data-type="method" id="ElvClient-PlayoutOptions-nav"><a href="ElvClient.html#PlayoutOptions" class="method-link">PlayoutOptions</a></li><li data-type="method" id="ElvClient-StartABRMezzanineJobs-nav"><a href="ElvClient.html#StartABRMezzanineJobs" class="method-link">StartABRMezzanineJobs</a></li><h4 class="methodGroupHeader">Metadata</h4><li data-type="method" id="ElvClient-ContentObjectMetadata-nav"><a href="ElvClient.html#ContentObjectMetadata" class="method-link">ContentObjectMetadata</a></li><li data-type="method" id="ElvClient-DeleteMetadata-nav"><a href="ElvClient.html#DeleteMetadata" class="method-link">DeleteMetadata</a></li><li data-type="method" id="ElvClient-MergeMetadata-nav"><a href="ElvClient.html#MergeMetadata" class="method-link">MergeMetadata</a></li><li data-type="method" id="ElvClient-ReplaceMetadata-nav"><a href="ElvClient.html#ReplaceMetadata" class="method-link">ReplaceMetadata</a></li><h4 class="methodGroupHeader">Miscellaneous</h4><li data-type="method" id="ElvClient-ToggleLogging-nav"><a href="ElvClient.html#ToggleLogging" class="method-link">ToggleLogging</a></li><h4 class="methodGroupHeader">Nodes</h4><li data-type="method" id="ElvClient-NodeId-nav"><a href="ElvClient.html#NodeId" class="method-link">NodeId</a></li><li data-type="method" id="ElvClient-Nodes-nav"><a href="ElvClient.html#Nodes" class="method-link">Nodes</a></li><li data-type="method" id="ElvClient-ResetRegion-nav"><a href="ElvClient.html#ResetRegion" class="method-link">ResetRegion</a></li><li data-type="method" id="ElvClient-SetNodes-nav"><a href="ElvClient.html#SetNodes" class="method-link">SetNodes</a></li><li data-type="method" id="ElvClient-UseRegion-nav"><a href="ElvClient.html#UseRegion" class="method-link">UseRegion</a></li><h4 class="methodGroupHeader">Parts and Files</h4><li data-type="method" id="ElvClient-ContentPart-nav"><a href="ElvClient.html#ContentPart" class="method-link">ContentPart</a></li><li data-type="method" id="ElvClient-ContentParts-nav"><a href="ElvClient.html#ContentParts" class="method-link">ContentParts</a></li><li data-type="method" id="ElvClient-CreateFileDirectories-nav"><a href="ElvClient.html#CreateFileDirectories" class="method-link">CreateFileDirectories</a></li><li data-type="method" id="ElvClient-CreatePart-nav"><a href="ElvClient.html#CreatePart" class="method-link">CreatePart</a></li><li data-type="method" id="ElvClient-DeleteFiles-nav"><a href="ElvClient.html#DeleteFiles" class="method-link">DeleteFiles</a></li><li data-type="method" id="ElvClient-DeletePart-nav"><a href="ElvClient.html#DeletePart" class="method-link">DeletePart</a></li><li data-type="method" id="ElvClient-DownloadFile-nav"><a href="ElvClient.html#DownloadFile" class="method-link">DownloadFile</a></li><li data-type="method" id="ElvClient-DownloadPart-nav"><a href="ElvClient.html#DownloadPart" class="method-link">DownloadPart</a></li><li data-type="method" id="ElvClient-FinalizePart-nav"><a href="ElvClient.html#FinalizePart" class="method-link">FinalizePart</a></li><li data-type="method" id="ElvClient-ListFiles-nav"><a href="ElvClient.html#ListFiles" class="method-link">ListFiles</a></li><li data-type="method" id="ElvClient-UploadFiles-nav"><a href="ElvClient.html#UploadFiles" class="method-link">UploadFiles</a></li><li data-type="method" id="ElvClient-UploadFilesFromS3-nav"><a href="ElvClient.html#UploadFilesFromS3" class="method-link">UploadFilesFromS3</a></li><li data-type="method" id="ElvClient-UploadPart-nav"><a href="ElvClient.html#UploadPart" class="method-link">UploadPart</a></li><li data-type="method" id="ElvClient-UploadPartChunk-nav"><a href="ElvClient.html#UploadPartChunk" class="method-link">UploadPartChunk</a></li><h4 class="methodGroupHeader">Signers</h4><li data-type="method" id="ElvClient-ClearSigner-nav"><a href="ElvClient.html#ClearSigner" class="method-link">ClearSigner</a></li><li data-type="method" id="ElvClient-CurrentAccountAddress-nav"><a href="ElvClient.html#CurrentAccountAddress" class="method-link">CurrentAccountAddress</a></li><li data-type="method" id="ElvClient-GenerateWallet-nav"><a href="ElvClient.html#GenerateWallet" class="method-link">GenerateWallet</a></li><li data-type="method" id="ElvClient-GetBalance-nav"><a href="ElvClient.html#GetBalance" class="method-link">GetBalance</a></li><li data-type="method" id="ElvClient-SendFunds-nav"><a href="ElvClient.html#SendFunds" class="method-link">SendFunds</a></li><li data-type="method" id="ElvClient-SetSigner-nav"><a href="ElvClient.html#SetSigner" class="method-link">SetSigner</a></li><li data-type="method" id="ElvClient-SetSignerFromWeb3Provider-nav"><a href="ElvClient.html#SetSignerFromWeb3Provider" class="method-link">SetSignerFromWeb3Provider</a></li><h4 class="methodGroupHeader">URL Generation</h4><li data-type="method" id="ElvClient-CallBitcodeMethod-nav"><a href="ElvClient.html#CallBitcodeMethod" class="method-link">CallBitcodeMethod</a></li><li data-type="method" id="ElvClient-FabricUrl-nav"><a href="ElvClient.html#FabricUrl" class="method-link">FabricUrl</a></li><li data-type="method" id="ElvClient-FileUrl-nav"><a href="ElvClient.html#FileUrl" class="method-link">FileUrl</a></li><li data-type="method" id="ElvClient-PublicRep-nav"><a href="ElvClient.html#PublicRep" class="method-link">PublicRep</a></li><li data-type="method" id="ElvClient-Rep-nav"><a href="ElvClient.html#Rep" class="method-link">Rep</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="ElvClient-SetOauthToken-nav"><a href="ElvClient.html#SetOauthToken" class="method-link">SetOauthToken</a></li><li data-type="method" id="ElvClient-UpdateContentObjectGraph-nav"><a href="ElvClient.html#UpdateContentObjectGraph" class="method-link">UpdateContentObjectGraph</a></li></ul></li><li id="ElvWallet-nav">
          <div data-name="ElvWallet" class="class-link-container"><a class="class-link">ElvWallet</a></div><ul class='methods'><h4 class="methodGroupHeader">Constructor</h4><li data-type="method" id="ElvWallet-ElvWallet-nav"><a href="ElvWallet.html" class="method-link">ElvWallet</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="ElvWallet-AddAccount-nav"><a href="ElvWallet.html#AddAccount" class="method-link">AddAccount</a></li><li data-type="method" id="ElvWallet-AddAccountFromEncryptedPK-nav"><a href="ElvWallet.html#AddAccountFromEncryptedPK" class="method-link">AddAccountFromEncryptedPK</a></li><li data-type="method" id="ElvWallet-AddAccountFromMnemonic-nav"><a href="ElvWallet.html#AddAccountFromMnemonic" class="method-link">AddAccountFromMnemonic</a></li><li data-type="method" id="ElvWallet-GenerateEncryptedPrivateKey-nav"><a href="ElvWallet.html#GenerateEncryptedPrivateKey" class="method-link">GenerateEncryptedPrivateKey</a></li><li data-type="method" id="ElvWallet-GenerateMnemonic-nav"><a href="ElvWallet.html#GenerateMnemonic" class="method-link">GenerateMnemonic</a></li><li data-type="method" id="ElvWallet-GetAccount-nav"><a href="ElvWallet.html#GetAccount" class="method-link">GetAccount</a></li><li data-type="method" id="ElvWallet-GetAccountBalance-nav"><a href="ElvWallet.html#GetAccountBalance" class="method-link">GetAccountBalance</a></li><li data-type="method" id="ElvWallet-RemoveAccount-nav"><a href="ElvWallet.html#RemoveAccount" class="method-link">RemoveAccount</a></li></ul></li><li id="FrameClient-nav">
          <div data-name="FrameClient" class="class-link-container"><a class="class-link">FrameClient</a></div><ul class='methods'><h4 class="methodGroupHeader">Constructor</h4><li data-type="method" id="FrameClient-FrameClient-nav"><a href="FrameClient.html" class="method-link">FrameClient</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="FrameClient-AllowedMethods-nav"><a href="FrameClient.html#AllowedMethods" class="method-link">AllowedMethods</a></li><li data-type="method" id="FrameClient-PassRequest-nav"><a href="FrameClient.html#PassRequest" class="method-link">PassRequest</a></li></ul></li><li id="UserProfileClient-nav">
          <div data-name="UserProfileClient" class="class-link-container"><a class="class-link">UserProfileClient</a></div><ul class='methods'><h4 class="methodGroupHeader">Constructor</h4><li data-type="method" id="UserProfileClient-UserProfileClient-nav"><a href="UserProfileClient.html" class="method-link">UserProfileClient</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="UserProfileClient-AccessLevel-nav"><a href="UserProfileClient.html#AccessLevel" class="method-link">AccessLevel</a></li><li data-type="method" id="UserProfileClient-CollectedTags-nav"><a href="UserProfileClient.html#CollectedTags" class="method-link">CollectedTags</a></li><li data-type="method" id="UserProfileClient-DeleteUserMetadata-nav"><a href="UserProfileClient.html#DeleteUserMetadata" class="method-link">DeleteUserMetadata</a></li><li data-type="method" id="UserProfileClient-MergeUserMetadata-nav"><a href="UserProfileClient.html#MergeUserMetadata" class="method-link">MergeUserMetadata</a></li><li data-type="method" id="UserProfileClient-PublicUserMetadata-nav"><a href="UserProfileClient.html#PublicUserMetadata" class="method-link">PublicUserMetadata</a></li><li data-type="method" id="UserProfileClient-ReplaceUserMetadata-nav"><a href="UserProfileClient.html#ReplaceUserMetadata" class="method-link">ReplaceUserMetadata</a></li><li data-type="method" id="UserProfileClient-SetAccessLevel-nav"><a href="UserProfileClient.html#SetAccessLevel" class="method-link">SetAccessLevel</a></li><li data-type="method" id="UserProfileClient-SetUserProfileImage-nav"><a href="UserProfileClient.html#SetUserProfileImage" class="method-link">SetUserProfileImage</a></li><li data-type="method" id="UserProfileClient-UserMetadata-nav"><a href="UserProfileClient.html#UserMetadata" class="method-link">UserMetadata</a></li><li data-type="method" id="UserProfileClient-UserProfileImage-nav"><a href="UserProfileClient.html#UserProfileImage" class="method-link">UserProfileImage</a></li><li data-type="method" id="UserProfileClient-UserWalletAddress-nav"><a href="UserProfileClient.html#UserWalletAddress" class="method-link">UserWalletAddress</a></li><li data-type="method" id="UserProfileClient-WalletAddress-nav"><a href="UserProfileClient.html#WalletAddress" class="method-link">WalletAddress</a></li></ul></li></ul><h3>Modules</h3><ul><li id="ElvClient_ABRPublishing-nav">
          <div data-name="ElvClient/ABRPublishing" class="class-link-container"><a class="class-link">ElvClient/ABRPublishing</a></div><ul class='methods'><li data-type="method" id="ElvClient_ABRPublishing-ElvClient/ABRPublishing-nav"><a href="module-ElvClient_ABRPublishing.html" class="method-link">ElvClient/ABRPublishing</a></li><h4 class="methodGroupHeader">ABR Publishing</h4><li data-type="method" id="ElvClient_ABRPublishing-CreateABRMezzanine-nav"><a href="module-ElvClient_ABRPublishing.html#.CreateABRMezzanine" class="method-link">CreateABRMezzanine</a></li><li data-type="method" id="ElvClient_ABRPublishing-CreateProductionMaster-nav"><a href="module-ElvClient_ABRPublishing.html#.CreateProductionMaster" class="method-link">CreateProductionMaster</a></li><li data-type="method" id="ElvClient_ABRPublishing-FinalizeABRMezzanine-nav"><a href="module-ElvClient_ABRPublishing.html#.FinalizeABRMezzanine" class="method-link">FinalizeABRMezzanine</a></li><li data-type="method" id="ElvClient_ABRPublishing-LROStatus-nav"><a href="module-ElvClient_ABRPublishing.html#.LROStatus" class="method-link">LROStatus</a></li><li data-type="method" id="ElvClient_ABRPublishing-StartABRMezzanineJobs-nav"><a href="module-ElvClient_ABRPublishing.html#.StartABRMezzanineJobs" class="method-link">StartABRMezzanineJobs</a></li></ul></li><li id="ElvClient_AccessGroups-nav">
          <div data-name="ElvClient/AccessGroups" class="class-link-container"><a class="class-link">ElvClient/AccessGroups</a></div><ul class='methods'><li data-type="method" id="ElvClient_AccessGroups-ElvClient/AccessGroups-nav"><a href="module-ElvClient_AccessGroups.html" class="method-link">ElvClient/AccessGroups</a></li><h4 class="methodGroupHeader">Access Groups</h4><li data-type="method" id="ElvClient_AccessGroups-AccessGroupManagers-nav"><a href="module-ElvClient_AccessGroups.html#.exports.access.AccessGroupManagers" class="method-link">AccessGroupManagers</a></li><li data-type="method" id="ElvClient_AccessGroups-AccessGroupMembers-nav"><a href="module-ElvClient_AccessGroups.html#.exports.access.AccessGroupMembers" class="method-link">AccessGroupMembers</a></li><li data-type="method" id="ElvClient_AccessGroups-AccessGroupOwner-nav"><a href="module-ElvClient_AccessGroups.html#.exports.access.AccessGroupOwner" class="method-link">AccessGroupOwner</a></li><li data-type="method" id="ElvClient_AccessGroups-AddAccessGroupManager-nav"><a href="module-ElvClient_AccessGroups.html#.exports.manage.AddAccessGroupManager" class="method-link">AddAccessGroupManager</a></li><li data-type="method" id="ElvClient_AccessGroups-AddAccessGroupMember-nav"><a href="module-ElvClient_AccessGroups.html#.exports.manage.AddAccessGroupMember" class="method-link">AddAccessGroupMember</a></li><li data-type="method" id="ElvClient_AccessGroups-CreateAccessGroup-nav"><a href="module-ElvClient_AccessGroups.html#.exports.manage.CreateAccessGroup" class="method-link">CreateAccessGroup</a></li><li data-type="method" id="ElvClient_AccessGroups-DeleteAccessGroup-nav"><a href="module-ElvClient_AccessGroups.html#.exports.manage.DeleteAccessGroup" class="method-link">DeleteAccessGroup</a></li><li data-type="method" id="ElvClient_AccessGroups-RemoveAccessGroupManager-nav"><a href="module-ElvClient_AccessGroups.html#.exports.manage.RemoveAccessGroupManager" class="method-link">RemoveAccessGroupManager</a></li><li data-type="method" id="ElvClient_AccessGroups-RemoveAccessGroupMember-nav"><a href="module-ElvClient_AccessGroups.html#.exports.manage.RemoveAccessGroupMember" class="method-link">RemoveAccessGroupMember</a></li><h4 class="methodGroupHeader">Library Access Groups</h4><li data-type="method" id="ElvClient_AccessGroups-ContentLibraryGroupPermissions-nav"><a href="module-ElvClient_AccessGroups.html#.exports.access.ContentLibraryGroupPermissions" class="method-link">ContentLibraryGroupPermissions</a></li><li data-type="method" id="ElvClient_AccessGroups-AddContentLibraryGroup-nav"><a href="module-ElvClient_AccessGroups.html#.exports.manage.AddContentLibraryGroup" class="method-link">AddContentLibraryGroup</a></li><li data-type="method" id="ElvClient_AccessGroups-RemoveContentLibraryGroup-nav"><a href="module-ElvClient_AccessGroups.html#.exports.manage.RemoveContentLibraryGroup" class="method-link">RemoveContentLibraryGroup</a></li><h4 class="methodGroupHeader">Object Access Groups</h4><li data-type="method" id="ElvClient_AccessGroups-ContentObjectGroupPermissions-nav"><a href="module-ElvClient_AccessGroups.html#.exports.access.ContentObjectGroupPermissions" class="method-link">ContentObjectGroupPermissions</a></li><li data-type="method" id="ElvClient_AccessGroups-AddContentObjectGroupPermission-nav"><a href="module-ElvClient_AccessGroups.html#.exports.manage.AddContentObjectGroupPermission" class="method-link">AddContentObjectGroupPermission</a></li><li data-type="method" id="ElvClient_AccessGroups-RemoveContentObjectGroupPermission-nav"><a href="module-ElvClient_AccessGroups.html#.exports.manage.RemoveContentObjectGroupPermission" class="method-link">RemoveContentObjectGroupPermission</a></li></ul></li><li id="ElvClient_ContentManagement-nav">
          <div data-name="ElvClient/ContentManagement" class="class-link-container"><a class="class-link">ElvClient/ContentManagement</a></div><ul class='methods'><li data-type="method" id="ElvClient_ContentManagement-ElvClient/ContentManagement-nav"><a href="module-ElvClient_ContentManagement.html" class="method-link">ElvClient/ContentManagement</a></li><h4 class="methodGroupHeader">Access Requests</h4><li data-type="method" id="ElvClient_ContentManagement-SetAccessCharge-nav"><a href="module-ElvClient_ContentManagement.html#.SetAccessCharge" class="method-link">SetAccessCharge</a></li><h4 class="methodGroupHeader">Content Libraries</h4><li data-type="method" id="ElvClient_ContentManagement-AddLibraryContentType-nav"><a href="module-ElvClient_ContentManagement.html#.AddLibraryContentType" class="method-link">AddLibraryContentType</a></li><li data-type="method" id="ElvClient_ContentManagement-CreateContentLibrary-nav"><a href="module-ElvClient_ContentManagement.html#.CreateContentLibrary" class="method-link">CreateContentLibrary</a></li><li data-type="method" id="ElvClient_ContentManagement-DeleteContentLibrary-nav"><a href="module-ElvClient_ContentManagement.html#.DeleteContentLibrary" class="method-link">DeleteContentLibrary</a></li><li data-type="method" id="ElvClient_ContentManagement-RemoveLibraryContentType-nav"><a href="module-ElvClient_ContentManagement.html#.RemoveLibraryContentType" class="method-link">RemoveLibraryContentType</a></li><li data-type="method" id="ElvClient_ContentManagement-SetContentLibraryImage-nav"><a href="module-ElvClient_ContentManagement.html#.SetContentLibraryImage" class="method-link">SetContentLibraryImage</a></li><h4 class="methodGroupHeader">Content Objects</h4><li data-type="method" id="ElvClient_ContentManagement-CopyContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.CopyContentObject" class="method-link">CopyContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-CreateContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.CreateContentObject" class="method-link">CreateContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-DeleteContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.DeleteContentObject" class="method-link">DeleteContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-DeleteContentVersion-nav"><a href="module-ElvClient_ContentManagement.html#.DeleteContentVersion" class="method-link">DeleteContentVersion</a></li><li data-type="method" id="ElvClient_ContentManagement-EditContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.EditContentObject" class="method-link">EditContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-FinalizeContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.FinalizeContentObject" class="method-link">FinalizeContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-PublishContentVersion-nav"><a href="module-ElvClient_ContentManagement.html#.PublishContentVersion" class="method-link">PublishContentVersion</a></li><li data-type="method" id="ElvClient_ContentManagement-SetContentObjectImage-nav"><a href="module-ElvClient_ContentManagement.html#.SetContentObjectImage" class="method-link">SetContentObjectImage</a></li><h4 class="methodGroupHeader">Content Types</h4><li data-type="method" id="ElvClient_ContentManagement-CreateContentType-nav"><a href="module-ElvClient_ContentManagement.html#.CreateContentType" class="method-link">CreateContentType</a></li><h4 class="methodGroupHeader">Links</h4><li data-type="method" id="ElvClient_ContentManagement-CreateLinks-nav"><a href="module-ElvClient_ContentManagement.html#.CreateLinks" class="method-link">CreateLinks</a></li><li data-type="method" id="ElvClient_ContentManagement-UpdateContentObjectGraph-nav"><a href="module-ElvClient_ContentManagement.html#.UpdateContentObjectGraph" class="method-link">UpdateContentObjectGraph</a></li><h4 class="methodGroupHeader">Metadata</h4><li data-type="method" id="ElvClient_ContentManagement-DeleteMetadata-nav"><a href="module-ElvClient_ContentManagement.html#.DeleteMetadata" class="method-link">DeleteMetadata</a></li><li data-type="method" id="ElvClient_ContentManagement-MergeMetadata-nav"><a href="module-ElvClient_ContentManagement.html#.MergeMetadata" class="method-link">MergeMetadata</a></li><li data-type="method" id="ElvClient_ContentManagement-ReplaceMetadata-nav"><a href="module-ElvClient_ContentManagement.html#.ReplaceMetadata" class="method-link">ReplaceMetadata</a></li></ul></li><li id="ElvClient_Contracts-nav">
          <div data-name="ElvClient/Contracts" class="class-link-container"><a class="class-link">ElvClient/Contracts</a></div><ul class='methods'><li data-type="method" id="ElvClient_Contracts-ElvClient/Contracts-nav"><a href="module-ElvClient_Contracts.html" class="method-link">ElvClient/Contracts</a></li><h4 class="methodGroupHeader">Blockchain</h4><li data-type="method" id="ElvClient_Contracts-BlockNumber-nav"><a href="module-ElvClient_Contracts.html#.BlockNumber" class="method-link">BlockNumber</a></li><li data-type="method" id="ElvClient_Contracts-Events-nav"><a href="module-ElvClient_Contracts.html#.Events" class="method-link">Events</a></li><li data-type="method" id="ElvClient_Contracts-GetBalance-nav"><a href="module-ElvClient_Contracts.html#.GetBalance" class="method-link">GetBalance</a></li><li data-type="method" id="ElvClient_Contracts-SendFunds-nav"><a href="module-ElvClient_Contracts.html#.SendFunds" class="method-link">SendFunds</a></li><h4 class="methodGroupHeader">Contracts</h4><li data-type="method" id="ElvClient_Contracts-CallContractMethod-nav"><a href="module-ElvClient_Contracts.html#.CallContractMethod" class="method-link">CallContractMethod</a></li><li data-type="method" id="ElvClient_Contracts-CallContractMethodAndWait-nav"><a href="module-ElvClient_Contracts.html#.CallContractMethodAndWait" class="method-link">CallContractMethodAndWait</a></li><li data-type="method" id="ElvClient_Contracts-ContractEvents-nav"><a href="module-ElvClient_Contracts.html#.ContractEvents" class="method-link">ContractEvents</a></li><li data-type="method" id="ElvClient_Contracts-ContractName-nav"><a href="module-ElvClient_Contracts.html#.ContractName" class="method-link">ContractName</a></li><li data-type="method" id="ElvClient_Contracts-CustomContractAddress-nav"><a href="module-ElvClient_Contracts.html#.CustomContractAddress" class="method-link">CustomContractAddress</a></li><li data-type="method" id="ElvClient_Contracts-DeployContract-nav"><a href="module-ElvClient_Contracts.html#.DeployContract" class="method-link">DeployContract</a></li><li data-type="method" id="ElvClient_Contracts-ExtractEventFromLogs-nav"><a href="module-ElvClient_Contracts.html#.ExtractEventFromLogs" class="method-link">ExtractEventFromLogs</a></li><li data-type="method" id="ElvClient_Contracts-ExtractValueFromEvent-nav"><a href="module-ElvClient_Contracts.html#.ExtractValueFromEvent" class="method-link">ExtractValueFromEvent</a></li><li data-type="method" id="ElvClient_Contracts-FormatContractArguments-nav"><a href="module-ElvClient_Contracts.html#.FormatContractArguments" class="method-link">FormatContractArguments</a></li><li data-type="method" id="ElvClient_Contracts-SetCustomContentContract-nav"><a href="module-ElvClient_Contracts.html#.SetCustomContentContract" class="method-link">SetCustomContentContract</a></li></ul></li><li id="ElvClient_Files+Parts-nav">
          <div data-name="ElvClient/Files+Parts" class="class-link-container"><a class="class-link">ElvClient/Files+Parts</a></div><ul class='methods'><li data-type="method" id="ElvClient_Files+Parts-ElvClient/Files+Parts-nav"><a href="module-ElvClient_Files+Parts.html" class="method-link">ElvClient/Files+Parts</a></li><h4 class="methodGroupHeader">Files</h4><li data-type="method" id="ElvClient_Files+Parts-DownloadFile-nav"><a href="module-ElvClient_Files+Parts.html#.exports.access.DownloadFile" class="method-link">DownloadFile</a></li><li data-type="method" id="ElvClient_Files+Parts-CreateFileDirectories-nav"><a href="module-ElvClient_Files+Parts.html#.exports.manage.CreateFileDirectories" class="method-link">CreateFileDirectories</a></li><li data-type="method" id="ElvClient_Files+Parts-DeleteFiles-nav"><a href="module-ElvClient_Files+Parts.html#.exports.manage.DeleteFiles" class="method-link">DeleteFiles</a></li><li data-type="method" id="ElvClient_Files+Parts-ListFiles-nav"><a href="module-ElvClient_Files+Parts.html#.exports.manage.ListFiles" class="method-link">ListFiles</a></li><li data-type="method" id="ElvClient_Files+Parts-UploadFiles-nav"><a href="module-ElvClient_Files+Parts.html#.exports.manage.UploadFiles" class="method-link">UploadFiles</a></li><li data-type="method" id="ElvClient_Files+Parts-UploadFilesFromS3-nav"><a href="module-ElvClient_Files+Parts.html#.exports.manage.UploadFilesFromS3" class="method-link">UploadFilesFromS3</a></li><h4 class="methodGroupHeader">Parts</h4><li data-type="method" id="ElvClient_Files+Parts-ContentPart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.access.ContentPart" class="method-link">ContentPart</a></li><li data-type="method" id="ElvClient_Files+Parts-ContentParts-nav"><a href="module-ElvClient_Files+Parts.html#.exports.access.ContentParts" class="method-link">ContentParts</a></li><li data-type="method" id="ElvClient_Files+Parts-DownloadPart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.access.DownloadPart" class="method-link">DownloadPart</a></li><li data-type="method" id="ElvClient_Files+Parts-CreatePart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.manage.CreatePart" class="method-link">CreatePart</a></li><li data-type="method" id="ElvClient_Files+Parts-DeletePart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.manage.DeletePart" class="method-link">DeletePart</a></li><li data-type="method" id="ElvClient_Files+Parts-FinalizePart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.manage.FinalizePart" class="method-link">FinalizePart</a></li><li data-type="method" id="ElvClient_Files+Parts-UploadPart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.manage.UploadPart" class="method-link">UploadPart</a></li><li data-type="method" id="ElvClient_Files+Parts-UploadPartChunk-nav"><a href="module-ElvClient_Files+Parts.html#.exports.manage.UploadPartChunk" class="method-link">UploadPartChunk</a></li></ul></li></ul><h3>Namespaces</h3><ul><li id="Crypto-nav">
          <div data-name="Crypto" class="class-link-container"><a class="class-link">Crypto</a></div><ul class='methods'><li data-type="method" id="Crypto-Crypto-nav"><a href="Crypto.html" class="method-link">Crypto</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="Crypto-Decrypt-nav"><a href="Crypto.html#.Decrypt" class="method-link">Decrypt</a></li><li data-type="method" id="Crypto-Encrypt-nav"><a href="Crypto.html#.Encrypt" class="method-link">Encrypt</a></li></ul></li><li id="Utils-nav">
          <div data-name="Utils" class="class-link-container"><a class="class-link">Utils</a></div><ul class='methods'><li data-type="method" id="Utils-Utils-nav"><a href="Utils.html" class="method-link">Utils</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="Utils-AddressToHash-nav"><a href="Utils.html#.AddressToHash" class="method-link">AddressToHash</a></li><li data-type="method" id="Utils-AddressToLibraryId-nav"><a href="Utils.html#.AddressToLibraryId" class="method-link">AddressToLibraryId</a></li><li data-type="method" id="Utils-AddressToObjectId-nav"><a href="Utils.html#.AddressToObjectId" class="method-link">AddressToObjectId</a></li><li data-type="method" id="Utils-AddressToSpaceId-nav"><a href="Utils.html#.AddressToSpaceId" class="method-link">AddressToSpaceId</a></li><li data-type="method" id="Utils-DecodeAuthorizationToken-nav"><a href="Utils.html#.DecodeAuthorizationToken" class="method-link">DecodeAuthorizationToken</a></li><li data-type="method" id="Utils-DecodeVersionHash-nav"><a href="Utils.html#.DecodeVersionHash" class="method-link">DecodeVersionHash</a></li><li data-type="method" id="Utils-EqualAddress-nav"><a href="Utils.html#.EqualAddress" class="method-link">EqualAddress</a></li><li data-type="method" id="Utils-EqualHash-nav"><a href="Utils.html#.EqualHash" class="method-link">EqualHash</a></li><li data-type="method" id="Utils-EtherToWei-nav"><a href="Utils.html#.EtherToWei" class="method-link">EtherToWei</a></li><li data-type="method" id="Utils-FormatAddress-nav"><a href="Utils.html#.FormatAddress" class="method-link">FormatAddress</a></li><li data-type="method" id="Utils-FormatSignature-nav"><a href="Utils.html#.FormatSignature" class="method-link">FormatSignature</a></li><li data-type="method" id="Utils-HashToAddress-nav"><a href="Utils.html#.HashToAddress" class="method-link">HashToAddress</a></li><li data-type="method" id="Utils-IsCloneable-nav"><a href="Utils.html#.IsCloneable" class="method-link">IsCloneable</a></li><li data-type="method" id="Utils-MakeClonable-nav"><a href="Utils.html#.MakeClonable" class="method-link">MakeClonable</a></li><li data-type="method" id="Utils-ToBigNumber-nav"><a href="Utils.html#.ToBigNumber" class="method-link">ToBigNumber</a></li><li data-type="method" id="Utils-ToBytes32-nav"><a href="Utils.html#.ToBytes32" class="method-link">ToBytes32</a></li><li data-type="method" id="Utils-WeiToEther-nav"><a href="Utils.html#.WeiToEther" class="method-link">WeiToEther</a></li></ul></li></ul>
      </div>
    </nav>

    <div class="main">
      <div class="header"></div>
      <div class="main-content">
        
        <h1 class="page-title">
          ElvClient.js
        </h1>
        

        
      

<a class="button" href="ElvClient.html">Back</a>
<div class="source-container">
  <pre class="prettyprint source linenums"><code>if(typeof Buffer === "undefined") { Buffer = require("buffer/").Buffer; }

const UrlJoin = require("url-join");
const URI = require("urijs");
const Ethers = require("ethers");

const AuthorizationClient = require("./AuthorizationClient");
const ElvWallet = require("./ElvWallet");
const EthClient = require("./EthClient");
const UserProfileClient = require("./UserProfileClient");
const HttpClient = require("./HttpClient");
// const ContentObjectVerification = require("./ContentObjectVerification");
const Utils = require("./Utils");
const Crypto = require("./Crypto");

const SpaceContract = require("./contracts/BaseContentSpace");
const LibraryContract = require("./contracts/BaseLibrary");
const ContentContract = require("./contracts/BaseContent");
const ContentTypeContract = require("./contracts/BaseContentType");

const {
  ValidateLibrary,
  ValidateObject,
  ValidateVersion,
  ValidateWriteToken,
  ValidatePartHash,
  ValidateParameters
} = require("./Validation");

if(Utils.Platform() === Utils.PLATFORM_NODE) {
  // Define Response in node
  // eslint-disable-next-line no-global-assign
  global.Response = (require("node-fetch")).Response;
} else if(Utils.Platform() === Utils.PLATFORM_REACT_NATIVE) {
  // React native polyfill
  require("unorm");
}

class ElvClient {
  Log(message, error=false) {
    if(!this.debug) { return; }

    if(typeof message === "object") {
      message = JSON.stringify(message);
    }

    error ?
      // eslint-disable-next-line no-console
      console.error(`\n(elv-client-js#ElvClient) ${message}\n`) :
      // eslint-disable-next-line no-console
      console.log(`\n(elv-client-js#ElvClient) ${message}\n`);
  }

  /**
   * Enable or disable verbose logging
   *
   * @methodGroup Miscellaneous
   *
   * @param {boolean} enable - Set logging
   */
  ToggleLogging(enable) {
    this.debug = enable;
    this.authClient ? this.authClient.debug = enable : undefined;
    this.ethClient ? this.ethClient.debug = enable : undefined;
    this.HttpClient ? this.HttpClient.debug = enable : undefined;
    this.userProfileClient ? this.userProfileClient.debug = enable : undefined;

    if(enable) {
      this.Log(
        `Debug Logging Enabled:
        Content Space: ${this.contentSpaceId}
        Fabric URLs: [\n\t\t${this.fabricURIs.join(", \n\t\t")}\n\t]
        Ethereum URLs: [\n\t\t${this.ethereumURIs.join(", \n\t\t")}\n\t]`
      );
    }
  }

  /**
   * Create a new ElvClient
   *
   * @constructor
   *
   * @namedParams
   * @param {string} contentSpaceId - ID of the content space
   * @param {Array&lt;string>} fabricURIs - A list of full URIs to content fabric nodes
   * @param {Array&lt;string>} ethereumURIs - A list of full URIs to ethereum nodes
   * @param {boolean=} noCache=false - If enabled, blockchain transactions will not be cached
   * @param {boolean=} noAuth=false - If enabled, blockchain authorization will not be performed
   *
   * @return {ElvClient} - New ElvClient connected to the specified content fabric and blockchain
   */
  constructor({
    contentSpaceId,
    fabricURIs,
    ethereumURIs,
    kmsURIs,
    noCache=false,
    noAuth=false
  }) {
    this.utils = Utils;

    this.contentSpaceId = contentSpaceId;
    this.contentSpaceAddress = this.utils.HashToAddress(contentSpaceId);
    this.contentSpaceLibraryId = this.utils.AddressToLibraryId(this.contentSpaceAddress);
    this.contentSpaceObjectId = this.utils.AddressToObjectId(this.contentSpaceAddress);

    this.fabricURIs = fabricURIs;
    this.ethereumURIs = ethereumURIs;
    this.kmsURIs = kmsURIs;

    this.noCache = noCache;
    this.noAuth = noAuth;

    this.debug = false;

    this.InitializeClients();
  }

  /**
   * Retrieve content space info and preferred fabric and blockchain URLs from the fabric
   *
   * @methodGroup Constructor
   * @namedParams
   * @param {string} configUrl - Full URL to the config endpoint
   * @param {string=} region - Preferred region - the fabric will auto-detect the best region if not specified
   * - Available regions: na-west-north na-west-south na-east eu-west
   *
   * @return {Promise&lt;Object>} - Object containing content space ID and fabric and ethereum URLs
   */
  static async Configuration({
    configUrl,
    region
  }) {
    try {
      const uri = new URI(configUrl);

      if(region) {
        uri.addSearch("elvgeo", region);
      }

      const fabricInfo = await Utils.ResponseToJson(
        HttpClient.Fetch(uri.toString())
      );

      // If any HTTPS urls present, throw away HTTP urls so only HTTPS will be used
      const filterHTTPS = uri => uri.toLowerCase().startsWith("https");

      let fabricURIs = fabricInfo.network.seed_nodes.fabric_api;
      if(fabricURIs.find(filterHTTPS)) {
        fabricURIs = fabricURIs.filter(filterHTTPS);
      }

      let ethereumURIs = fabricInfo.network.seed_nodes.ethereum_api;
      if(ethereumURIs.find(filterHTTPS)) {
        ethereumURIs = ethereumURIs.filter(filterHTTPS);
      }

      return {
        nodeId: fabricInfo.node_id,
        contentSpaceId: fabricInfo.qspace.id,
        fabricURIs,
        ethereumURIs
      };
    } catch(error) {
      // eslint-disable-next-line no-console
      console.error("Error retrieving fabric configuration:");
      // eslint-disable-next-line no-console
      console.error(error);

      throw error;
    }
  }

  /**
   * Create a new ElvClient from the specified configuration URL
   *
   * @methodGroup Constructor
   * @namedParams
   * @param {string} configUrl - Full URL to the config endpoint
   * @param {Array&lt;string>} kmsURLs - List of KMS urls to use for OAuth authentication
   * @param {string=} region - Preferred region - the fabric will auto-detect the best region if not specified
   * - Available regions: na-west-north na-west-south na-east eu-west
   * @param {boolean=} noCache=false - If enabled, blockchain transactions will not be cached
   * @param {boolean=} noAuth=false - If enabled, blockchain authorization will not be performed
   *
   * @return {Promise&lt;ElvClient>} - New ElvClient connected to the specified content fabric and blockchain
   */
  static async FromConfigurationUrl({
    configUrl,
    kmsUrls=[],
    region,
    noCache=false,
    noAuth=false
  }) {
    const {
      contentSpaceId,
      fabricURIs,
      ethereumURIs
    } = await ElvClient.Configuration({
      configUrl,
      region
    });

    const client = new ElvClient({
      contentSpaceId,
      fabricURIs,
      ethereumURIs,
      kmsURIs: kmsUrls,
      noCache,
      noAuth
    });

    client.configUrl = configUrl;

    return client;
  }

  InitializeClients() {
    this.contentTypes = {};
    this.encryptionConks = {};
    this.reencryptionConks = {};
    this.stateChannelAccess = {};
    this.objectLibraryIds = {};

    this.HttpClient = new HttpClient({uris: this.fabricURIs, debug: this.debug});
    this.ethClient = new EthClient({uris: this.ethereumURIs, debug: this.debug});

    this.authClient = new AuthorizationClient({
      client: this,
      contentSpaceId: this.contentSpaceId,
      signer: this.signer,
      noCache: this.noCache,
      noAuth: this.noAuth,
      debug: this.debug
    });

    this.userProfileClient = new UserProfileClient({
      client: this,
      debug: this.debug
    });
  }

  SetAuth(auth) {
    this.noAuth = !auth;
    this.authClient.noAuth = !auth;
  }

  /**
   * Update fabric URLs to prefer the specified region.
   *
   * Note: Client must have been initialized with FromConfiguration
   *
   * @methodGroup Nodes
   * @namedParams
   * @param {string} region - Preferred region - the fabric will auto-detect the best region if not specified
   * - Available regions: na-west-north na-west-south na-east eu-west
   *
   * @return {Promise&lt;Object>} - An object containing the updated fabric and ethereum URLs in order of preference
   */
  async UseRegion({region}) {
    if(!this.configUrl) {
      throw Error("Unable to change region: Configuration URL not set");
    }

    const { fabricURIs, ethereumURIs } = await ElvClient.Configuration({
      configUrl: this.configUrl,
      region
    });

    this.fabricURIs = fabricURIs;
    this.ethereumURIs = ethereumURIs;

    this.HttpClient.uris = fabricURIs;
    this.HttpClient.uriIndex = 0;

    this.ethClient.ethereumURIs = ethereumURIs;
    this.ethClient.ethereumURIIndex = 0;

    return {
      fabricURIs,
      ethereumURIs
    };
  }

  /**
   * Reset fabric URLs to prefer the best region auto-detected by the fabric.
   *
   * Note: Client must have been initialized with FromConfiguration
   *
   * @methodGroup Nodes
   *
   * @return {Promise&lt;Object>} - An object containing the updated fabric and ethereum URLs in order of preference
   */
  async ResetRegion() {
    if(!this.configUrl) {
      throw Error("Unable to change region: Configuration URL not set");
    }

    return await this.UseRegion({region: ""});
  }

  /**
   * Retrieve the node ID reported by the fabric for the specified region
   *
   * Note: Client must have been initialized with FromConfiguration
   *
   * @methodGroup Nodes
   *
   * @namedParams
   * @param {string} region - Region from which to retrieve the node ID
   *
   * @return {Promise&lt;string>} - The node ID reported by the fabric
   */
  async NodeId({region}) {
    const { nodeId } = await ElvClient.Configuration({
      configUrl: this.configUrl,
      region
    });

    return nodeId;
  }

  /**
   * Retrieve the fabric and ethereum nodes currently used by the client, in preference order
   *
   * @methodGroup Nodes
   *
   * @return {Promise&lt;Object>} - An object containing the lists of fabric and ethereum urls in use by the client
   */
  Nodes() {
    return {
      fabricURIs: this.fabricURIs,
      ethereumURIs: this.ethereumURIs
    };
  }

  /**
   * Set the client to use the specified fabric and ethereum nodes, in preference order
   *
   * @namedParams
   * @param {Array&lt;string>=} fabricURIs - A list of URLs for the fabric, in preference order
   * @param {Array&lt;string>=} ethereumURIs - A list of URLs for the blockchain, in preference order
   *
   * @methodGroup Nodes
   */
  SetNodes({fabricURIs, ethereumURIs}) {
    if(fabricURIs) {
      this.fabricURIs = fabricURIs;

      this.HttpClient.uris = fabricURIs;
      this.HttpClient.uriIndex = 0;
    }

    if(ethereumURIs) {
      this.ethereumURIs = ethereumURIs;

      this.ethClient.ethereumURIs = ethereumURIs;
      this.ethClient.ethereumURIIndex = 0;
    }
  }

  /* Wallet and signers */

  /**
   * Generate a new ElvWallet that is connected to the client's provider
   *
   * @methodGroup Signers
   * @returns {ElvWallet} - ElvWallet instance with this client's provider
   */
  GenerateWallet() {
    return new ElvWallet(this.ethClient.Provider());
  }

  /**
   * Remove the signer from this client
   *
   * @methodGroup Signers
   */
  ClearSigner() {
    this.signer = undefined;

    this.InitializeClients();
  }

  /**
   * Clear saved access and state channel tokens
   *
   * @methodGroup Access Requests
   */
  ClearCache() {
    this.authClient.ClearCache();
  }

  /**
   * Set the signer for this client to use for blockchain transactions
   *
   * @methodGroup Signers
   * @namedParams
   * @param {object} signer - The ethers.js signer object
   */
  SetSigner({signer}) {
    signer.connect(this.ethClient.Provider());
    signer.provider.pollingInterval = 250;
    this.signer = signer;

    this.InitializeClients();
  }

  /**
   * Set the signer for this client to use for blockchain transactions from an existing web3 provider.
   * Useful for integrating with MetaMask
   *
   * @see https://github.com/ethers-io/ethers.js/issues/59#issuecomment-358224800
   *
   * @methodGroup Signers
   * @namedParams
   * @param {object} provider - The web3 provider object
   */
  async SetSignerFromWeb3Provider({provider}) {
    let ethProvider = new Ethers.providers.Web3Provider(provider);
    ethProvider.pollingInterval = 250;
    this.signer = ethProvider.getSigner();
    this.signer.address = await this.signer.getAddress();
    await this.InitializeClients();
  }

  /**
   * Get the account address of the current signer
   *
   * @methodGroup Signers
   * @returns {string} - The address of the current signer
   */
  CurrentAccountAddress() {
    return this.signer ? this.utils.FormatAddress(this.signer.address) : "";
  }

  /**
   * Set the signer for this client via OAuth token. The client will exchange the given token
   * for the user's private key using the KMS specified in the configuration.
   *
   * NOTE: The KMS URL(s) must be set in the initial configuration of the client (FromConfigurationUrl)
   *
   * @param {string} token - The OAuth ID token to authenticate with
   */
  async SetOauthToken({token}) {
    if(!this.kmsURIs || this.kmsURIs.length === 0) {
      throw Error("Unable to authorize with OAuth token: No KMS URLs set");
    }

    this.oauthToken = token;

    const path = "/ks/jwt/wlt";
    const httpClient = new HttpClient({uris: this.kmsURIs});

    const response = await ResponseToJson(
      httpClient.Request({
        headers: { Authorization: `Bearer ${token}`},
        method: "PUT",
        path
      })
    );

    const privateKey = response["UserSKHex"];

    const wallet = this.GenerateWallet();
    const signer = wallet.AddAccount({privateKey});

    this.SetSigner({signer});
  }

  /* Content Spaces */

  /**
   * Get the address of the default KMS of the content space
   *
   * @methodGroup Content Space
   *
   * @returns {Promise&lt;string>} - Address of the KMS
   */
  async DefaultKMSAddress() {
    return await this.CallContractMethod({
      contractAddress: this.contentSpaceAddress,
      abi: SpaceContract.abi,
      methodName: "addressKMS",
    });
  }

  /**
   * Get the ID of the current content space
   *
   * @methodGroup Content Space
   *
   * @return {string} contentSpaceId - The ID of the current content space
   */
  ContentSpaceId() {
    return this.contentSpaceId;
  }

  /* Libraries */

  /**
   * List content libraries - returns a list of content library IDs available to the current user
   *
   * @methodGroup Content Libraries
   *
   * @returns {Promise&lt;Array&lt;string>>}
   */
  async ContentLibraries() {
    const libraryAddresses = await this.Collection({collectionType: "libraries"});

    return libraryAddresses.map(address => this.utils.AddressToLibraryId(address));
  }

  /**
   * Returns information about the content library
   *
   * @methodGroup Content Libraries
   *
   * @namedParams
   * @param {string} libraryId
   *
   * @returns {Promise&lt;Object>}
   */
  async ContentLibrary({libraryId}) {
    ValidateLibrary(libraryId);

    const path = UrlJoin("qlibs", libraryId);

    const library = await this.utils.ResponseToJson(
      this.HttpClient.Request({
        headers: await this.authClient.AuthorizationHeader({libraryId}),
        method: "GET",
        path: path
      })
    );

    return {
      ...library,
      meta: library.meta || {}
    };
  }

  /**
   * Returns the address of the owner of the specified content library
   *
   * @methodGroup Content Libraries
   * @namedParams
   * @param {string} libraryId
   *
   * @returns {Promise&lt;string>} - The account address of the owner
   */
  async ContentLibraryOwner({libraryId}) {
    ValidateLibrary(libraryId);

    return this.utils.FormatAddress(
      await this.ethClient.CallContractMethod({
        contractAddress: Utils.HashToAddress(libraryId),
        abi: LibraryContract.abi,
        methodName: "owner",
        methodArgs: [],
        signer: this.signer
      })
    );
  }

  /**
   * Retrieve the allowed content types for the specified library.
   *
   * Note: If no content types have been set on the library, all types are allowed, but an empty hash will be returned.
   *
   * @see &lt;a href="#ContentTypes">ContentTypes&lt;/a>
   *
   * @methodGroup Content Libraries
   * @namedParams
   * @param {string} libraryId - ID of the library
   *
   * @returns {Promise&lt;Object>} - List of accepted content types - return format is equivalent to ContentTypes method
   */
  async LibraryContentTypes({libraryId}) {
    ValidateLibrary(libraryId);

    this.Log(`Retrieving library content types for ${libraryId}`);

    const typesLength = (await this.ethClient.CallContractMethod({
      contractAddress: Utils.HashToAddress(libraryId),
      abi: LibraryContract.abi,
      methodName: "contentTypesLength",
      methodArgs: [],
      signer: this.signer
    })).toNumber();

    this.Log(`${typesLength} types`);

    // No allowed types set - any type accepted
    if(typesLength === 0) { return {}; }

    // Get the list of allowed content type addresses
    let allowedTypes = {};
    await Promise.all(
      Array.from(new Array(typesLength), async (_, i) => {
        const typeAddress = await this.ethClient.CallContractMethod({
          contractAddress: Utils.HashToAddress(libraryId),
          abi: LibraryContract.abi,
          methodName: "contentTypes",
          methodArgs: [i],
          signer: this.signer
        });

        const typeId = this.utils.AddressToObjectId(typeAddress);
        allowedTypes[typeId] = await this.ContentType({typeId});
      })
    );

    this.Log(allowedTypes);

    return allowedTypes;
  }

  /* Content Types */

  /**
   * Returns the address of the owner of the specified content type
   *
   * @methodGroup Content Types
   * @namedParams
   * @param {string=} name - Name of the content type to find
   * @param {string=} typeId - ID of the content type to find
   * @param {string=} versionHash - Version hash of the content type to find
   *
   * @returns {Promise&lt;string>} - The account address of the owner
   */
  async ContentTypeOwner({name, typeId, versionHash}) {
    const contentType = await this.ContentType({name, typeId, versionHash});

    return this.utils.FormatAddress(
      await this.ethClient.CallContractMethod({
        contractAddress: Utils.HashToAddress(contentType.id),
        abi: ContentTypeContract.abi,
        methodName: "owner",
        methodArgs: [],
        signer: this.signer
      })
    );
  }

  /**
   * Find the content type accessible to the current user by name, ID, or version hash
   *
   * @methodGroup Content Types
   * @namedParams
   * @param {string=} name - Name of the content type to find
   * @param {string=} typeId - ID of the content type to find
   * @param {string=} versionHash - Version hash of the content type to find
   *
   * @return {Promise&lt;Object>} - The content type, if found
   */
  async ContentType({name, typeId, versionHash}) {
    this.Log(`Retrieving content type: ${name || typeId || versionHash}`);

    if(versionHash) { typeId = this.utils.DecodeVersionHash(versionHash).objectId; }

    if(name) {
      this.Log("Looking up type by name in content space metadata...");
      // Look up named type in content space metadata
      typeId = await this.ContentObjectMetadata({
        libraryId: this.contentSpaceLibraryId,
        objectId: this.contentSpaceObjectId,
        metadataSubtree: UrlJoin("contentTypes", name)
      });
    }

    if(!typeId) {
      this.Log("Looking up type by name in available types...");
      const types = await this.ContentTypes();

      if(name) {
        return Object.values(types).find(type => (type.name || "").toLowerCase() === name.toLowerCase());
      } else {
        return Object.values(types).find(type => type.hash === versionHash);
      }
    }

    try {
      this.Log("Looking up type by ID...");

      const typeInfo = await this.ContentObject({
        libraryId: this.contentSpaceLibraryId,
        objectId: typeId
      });

      delete typeInfo.type;

      const metadata = (await this.ContentObjectMetadata({
        libraryId: this.contentSpaceLibraryId,
        objectId: typeId
      })) || {};

      return {
        ...typeInfo,
        name: metadata.name,
        meta: metadata
      };
    } catch(error) {
      this.Log("Error looking up content type:");
      this.Log(error);
      throw new Error(`Content Type ${name || typeId} is invalid`);
    }
  }

  /**
   * List all content types accessible to this user.
   *
   * @methodGroup Content Types
   * @namedParams
   *
   * @return {Promise&lt;Object>} - Available content types
   */
  async ContentTypes() {
    this.contentTypes = this.contentTypes || {};

    this.Log("Looking up all available content types");

    // Personally available types
    let typeAddresses = await this.Collection({collectionType: "contentTypes"});

    this.Log("Personally available types:");
    this.Log(typeAddresses);

    // Content space types
    const contentSpaceTypes = await this.ContentObjectMetadata({
      libraryId: this.contentSpaceLibraryId,
      objectId: this.contentSpaceObjectId,
      metadataSubtree: "contentTypes"
    }) || {};

    const contentSpaceTypeAddresses = Object.values(contentSpaceTypes)
      .map(typeId => this.utils.HashToAddress(typeId));

    this.Log("Content space types:");
    this.Log(contentSpaceTypeAddresses);

    typeAddresses = typeAddresses
      .concat(contentSpaceTypeAddresses)
      .filter(address => address)
      .map(address => this.utils.FormatAddress(address))
      .filter((v, i, a) => a.indexOf(v) === i);

    await Promise.all(
      typeAddresses.map(async typeAddress => {
        const typeId = this.utils.AddressToObjectId(typeAddress);

        if(!this.contentTypes[typeId]) {
          try {
            this.contentTypes[typeId] = await this.ContentType({typeId});
          } catch(error) {
            // eslint-disable-next-line no-console
            // console.error(error);
          }
        }
      })
    );

    return this.contentTypes;
  }



  /* Objects */

  /**
   * List content objects in the specified library
   *
   * @methodGroup Content Objects
   * @namedParams
   * @param {string} libraryId - ID of the library
   * @param {object=} filterOptions - Pagination, sorting and filtering options
   * @param {boolean=} filterOptions.latestOnly=true - If specified, only latest version of objects will be included
   * @param {number=} filterOptions.start - Start index for pagination
   * @param {number=} filterOptions.limit - Max number of objects to return
   * @param {string=} filterOptions.cacheId - Cache ID corresponding a previous query
   * @param {(Array&lt;string> | string)=} filterOptions.sort - Sort by the specified key(s)
   * * @param {boolean=} filterOptions.sortDesc=false - Sort in descending order
   * @param {(Array&lt;string> | string)=} filterOptions.select - Include only the specified metadata keys
   * @param {(Array&lt;object> | object)=} filterOptions.filter - Filter objects by metadata
   * @param {string=} filterOptions.filter.key - Key to filter on
   * @param {string=} filterOptions.filter.type - Type of filter to use for the specified key:
   * - eq, neq, lt, lte, gt, gte, cnt (contains), ncnt (does not contain),
   * @param {string=} filterOptions.filter.filter - Filter for the specified key
   *
   * @returns {Promise&lt;Array&lt;Object>>} - List of objects in library
   */
  async ContentObjects({libraryId, filterOptions={}}) {
    ValidateLibrary(libraryId);

    this.Log(`Retrieving content objects from ${libraryId}`);

    let path = UrlJoin("qlibs", libraryId, "q");

    let queryParams = {
      filter: []
    };

    // Cache ID
    if(filterOptions.cacheId) {
      queryParams.cache_id = filterOptions.cacheId;
    }

    // Start index
    if(filterOptions.start) {
      queryParams.start = filterOptions.start;
    }

    // Limit
    if(filterOptions.limit) {
      queryParams.limit = filterOptions.limit;
    }

    // Metadata select options
    if(filterOptions.select) {
      queryParams.select = filterOptions.select;
    }

    // Sorting options
    if(filterOptions.sort) {
      // Sort keys
      queryParams.sort_by = filterOptions.sort;

      // Sort order
      if(filterOptions.sortDesc) {
        queryParams.sort_descending = true;
      }
    }

    if(filterOptions.latestOnly === false) {
      queryParams.latest_version_only = false;
    }

    // Filters
    const filterTypeMap = {
      eq: ":eq:",
      neq: ":ne:",
      lt: ":lt:",
      lte: ":le:",
      gt: ":gt:",
      gte: ":ge:",
      cnt: ":co:",
      ncnt: ":nc:"
    };

    const addFilter = ({key, type, filter}) => {
      queryParams.filter.push(`${key}${filterTypeMap[type]}${filter}`);
    };

    if(filterOptions.filter) {
      if(Array.isArray(filterOptions.filter)) {
        filterOptions.filter.forEach(filter => addFilter(filter));
      } else {
        addFilter(filterOptions.filter);
      }
    }

    this.Log("Filter options:");
    this.Log(filterOptions);

    return await this.utils.ResponseToJson(
      this.HttpClient.Request({
        headers: await this.authClient.AuthorizationHeader({libraryId}),
        method: "GET",
        path: path,
        queryParams
      })
    );
  }

  /**
   * Get a specific content object in the library
   *
   * @methodGroup Content Objects
   * @namedParams
   * @param {string=} libraryId - ID of the library
   * @param {string=} objectId - ID of the object
   * @param {string=} versionHash - Version hash of the object -- if not specified, latest version is returned
   *
   * @returns {Promise&lt;Object>} - Description of content object
   */
  async ContentObject({libraryId, objectId, versionHash}) {
    ValidateParameters({libraryId, objectId, versionHash});

    this.Log(`Retrieving content object: ${libraryId || ""} ${objectId || versionHash}`);

    if(versionHash) { objectId = this.utils.DecodeVersionHash(versionHash).objectId; }

    let path = UrlJoin("q", versionHash || objectId);

    return await this.utils.ResponseToJson(
      this.HttpClient.Request({
        headers: await this.authClient.AuthorizationHeader({libraryId, objectId, versionHash, noAuth: true}),
        method: "GET",
        path: path
      })
    );
  }

  /**
   * Returns the address of the owner of the specified content object
   *
   * @methodGroup Content Objects
   * @namedParams
   * @param {string} libraryId
   *
   * @returns {Promise&lt;string>} - The account address of the owner
   */
  async ContentObjectOwner({objectId}) {
    ValidateObject(objectId);

    this.Log(`Retrieving content object owner: ${objectId}`);

    return this.utils.FormatAddress(
      await this.ethClient.CallContractMethod({
        contractAddress: Utils.HashToAddress(objectId),
        abi: ContentContract.abi,
        methodName: "owner",
        methodArgs: [],
        cacheContract: false,
        signer: this.signer
      })
    );
  }

  /**
   * Retrieve the library ID for the specified content object
   *
   * @methodGroup Content Objects
   *
   * @namedParams
   * @param {string=} objectId - ID of the object
   * @param {string=} versionHash - Version hash of the object
   *
   * @returns {Promise&lt;string>} - Library ID of the object
   */
  async ContentObjectLibraryId({objectId, versionHash}) {
    versionHash ? ValidateVersion(versionHash) : ValidateObject(objectId);

    if(versionHash) { objectId = this.utils.DecodeVersionHash(versionHash).objectId; }

    if(!this.objectLibraryIds[objectId]) {
      this.Log(`Retrieving content object library ID: ${objectId || versionHash}`);

      this.objectLibraryIds[objectId] = Utils.AddressToLibraryId(
        await this.CallContractMethod({
          contractAddress: Utils.HashToAddress(objectId),
          abi: ContentContract.abi,
          methodName: "libraryAddress"
        })
      );
    }

    return this.objectLibraryIds[objectId];
  }

  async ProduceMetadataLinks({
    libraryId,
    objectId,
    versionHash,
    path="/",
    metadata,
    noAuth=true
  }) {
    // Primitive
    if(!metadata || typeof metadata !== "object") { return metadata; }

    // Array
    if(Array.isArray(metadata)) {
      return await this.utils.LimitedMap(
        5,
        metadata,
        async (entry, i) => await this.ProduceMetadataLinks({
          libraryId,
          objectId,
          versionHash,
          path: UrlJoin(path, i.toString()),
          metadata: entry,
          noAuth
        })
      );
    }

    // Object
    if(metadata["/"] &amp;&amp;
      (metadata["/"].match(/\.\/(rep|files)\/.+/) ||
        metadata["/"].match(/^\/?qfab\/([\w]+)\/?(rep|files)\/.+/)))
    {
      // Is file or rep link - produce a url
      return {
        ...metadata,
        url: await this.LinkUrl({libraryId, objectId, versionHash, linkPath: path})
      };
    }

    let result = {};
    await this.utils.LimitedMap(
      5,
      Object.keys(metadata),
      async key => {
        result[key] = await this.ProduceMetadataLinks({
          libraryId,
          objectId,
          versionHash,
          path: UrlJoin(path, key),
          metadata: metadata[key],
          noAuth
        });
      }
    );

    return result;
  }

  /**
   * Get the metadata of a content object
   *
   * @methodGroup Metadata
   * @namedParams
   * @param {string=} libraryId - ID of the library
   * @param {string=} objectId - ID of the object
   * @param {string=} versionHash - Version of the object -- if not specified, latest version is used
   * @param {string=} writeToken - Write token of an object draft - if specified, will read metadata from the draft
   * @param {string=} metadataSubtree - Subtree of the object metadata to retrieve
   * @param {boolean=} resolveLinks=false - If specified, links in the metadata will be resolved
   * @param {boolean=} resolveIncludeSource=false - If specified, resolved links will include the hash of the link at the root of the metadata

      Example:
       {
          "resolved-link": {
            ".": {
              "source": "hq__HPXNia6UtXyuUr6G3Lih8PyUhvYYHuyLTt3i7qSfYgYBB7sF1suR7ky7YRXsUARUrTB1Um1x5a"
            },
            ...
          }
       }

   * @param {boolean=} produceLinkUrls=false - If specified, file and rep links will automatically be populated with a
   * full URL
   * @param {boolean=} noAuth=false - If specified, authorization will not be performed for this call
   *
   * @returns {Promise&lt;Object | string>} - Metadata of the content object
   */
  async ContentObjectMetadata({
    libraryId,
    objectId,
    versionHash,
    writeToken,
    metadataSubtree="/",
    resolveLinks=false,
    resolveIncludeSource=false,
    produceLinkUrls=false,
    noAuth=true
  }) {
    ValidateParameters({libraryId, objectId, versionHash});

    this.Log(
      `Retrieving content object metadata: ${libraryId || ""} ${objectId || versionHash} ${writeToken || ""}
       Subtree: ${metadataSubtree}`
    );

    if(versionHash) { objectId = this.utils.DecodeVersionHash(versionHash).objectId; }

    let path = UrlJoin("q", writeToken || versionHash || objectId, "meta", metadataSubtree);

    let metadata;
    try {
      metadata = await this.utils.ResponseToJson(
        this.HttpClient.Request({
          headers: await this.authClient.AuthorizationHeader({libraryId, objectId, versionHash, noAuth}),
          queryParams: {
            resolve: resolveLinks,
            resolve_include_source: resolveIncludeSource
          },
          method: "GET",
          path: path
        })
      );
    } catch(error) {
      if(error.status !== 404) {
        throw error;
      }

      metadata = metadataSubtree === "/" ? {} : undefined;
    }

    if(!produceLinkUrls) { return metadata; }

    return await this.ProduceMetadataLinks({
      libraryId,
      objectId,
      versionHash,
      path: metadataSubtree,
      metadata,
      noAuth
    });
  }

  /**
   * List the versions of a content object
   *
   * @methodGroup Content Objects
   * @namedParams
   * @param {string} libraryId - ID of the library
   * @param {string} objectId - ID of the object
   *
   * @returns {Promise&lt;Object>} - Response containing versions of the object
   */
  async ContentObjectVersions({libraryId, objectId, noAuth=false}) {
    ValidateParameters({libraryId, objectId});

    this.Log(`Retrieving content object versions: ${libraryId || ""} ${objectId || versionHash}`);

    let path = UrlJoin("qid", objectId);

    return this.utils.ResponseToJson(
      this.HttpClient.Request({
        headers: await this.authClient.AuthorizationHeader({libraryId, objectId, noAuth}),
        method: "GET",
        path: path
      })
    );
  }

  /**
   * Retrieve the version hash of the latest version of the specified object
   *
   * @methodGroup Content Objects
   * @namedParams
   * @param {string=} objectId - ID of the object
   * @param {string=} versionHash - Version hash of the object
   *
   * @returns {Promise&lt;string>} - The latest version hash of the object
   */
  async LatestVersionHash({objectId, versionHash}) {
    if(versionHash) { objectId = this.utils.DecodeVersionHash(versionHash).objectId; }

    ValidateObject(objectId);

    return await this.CallContractMethod({
      contractAddress: this.utils.HashToAddress(objectId),
      abi: ContentContract.abi,
      methodName: "objectHash"
    });
  }

  /* Encryption */

  /**
   * Retrieve the encryption conk for the specified object. If one has not yet been created
   * and a writeToken has been specified, this method will create a new conk and
   * save it to the draft metadata
   *
   * @methodGroup Encryption
   *
   * @namedParams
   * @param {string} libraryId - ID of the library
   * @param {string} objectId - ID of the object
   * @param {string=} writeToken - Write token of the content object draft
   *
   * @return Promise&lt;Object> - The encryption conk for the object
   */
  async EncryptionConk({libraryId, objectId, writeToken}) {
    ValidateParameters({libraryId, objectId});
    if(writeToken) { ValidateWriteToken(writeToken); }

    const owner = await this.authClient.Owner({id: objectId, abi: ContentContract.abi});

    if(!this.utils.EqualAddress(owner, this.signer.address)) {
      // Target decryption
      if(!this.reencryptionConks[objectId]) {
        this.reencryptionConks[objectId] = await this.authClient.ReEncryptionConk({libraryId, objectId});
      }

      return this.reencryptionConks[objectId];
    }

    // Primary encryption
    if(!this.encryptionConks[objectId]) {
      const capKey = `eluv.caps.iusr${this.utils.AddressToHash(this.signer.address)}`;

      const existingUserCap =
        await this.ContentObjectMetadata({
          libraryId,
          // Cap may only exist in draft
          objectId,
          writeToken,
          metadataSubtree: capKey
        });

      if(existingUserCap) {
        this.encryptionConks[objectId] = await Crypto.DecryptCap(existingUserCap, this.signer.signingKey.privateKey);
      } else {
        this.encryptionConks[objectId] = await Crypto.GeneratePrimaryConk();

        // If write token is specified, add it to the metadata
        if(writeToken) {
          let metadata = {};
          metadata[capKey] = await Crypto.EncryptConk(this.encryptionConks[objectId], this.signer.signingKey.publicKey);

          try {
            const kmsAddress = await this.authClient.KMSAddress({objectId});
            const kmsPublicKey = (await this.authClient.KMSInfo({objectId})).publicKey;
            const kmsCapKey = `eluv.caps.ikms${this.utils.AddressToHash(kmsAddress)}`;
            const existingKMSCap =
              await this.ContentObjectMetadata({
                libraryId,
                // Cap may only exist in draft
                objectId,
                writeToken,
                metadataSubtree: kmsCapKey
              });

            if(!existingKMSCap) {
              metadata[kmsCapKey] = await Crypto.EncryptConk(this.encryptionConks[objectId], kmsPublicKey);
            }
          } catch(error) {
            // eslint-disable-next-line no-console
            console.error("Failed to create encryption cap for KMS with public key " + kmsPublicKey);
          }

          await this.MergeMetadata({
            libraryId,
            objectId,
            writeToken,
            metadata
          });
        }
      }
    }

    return this.encryptionConks[objectId];
  }

  /**
   * Encrypt the specified chunk for the specified object or draft
   *
   * @methodGroup Encryption
   *
   * @namedParams
   * @param {string} libraryId - ID of the library
   * @param {string} objectId - ID of the object
   * @param {string} writeToken - Write token of the content object draft
   * @param {ArrayBuffer | Buffer} chunk - The data to encrypt
   *
   * @return {Promise&lt;ArrayBuffer>}
   */
  async Encrypt({libraryId, objectId, writeToken, chunk}) {
    ValidateParameters({libraryId, objectId});

    const conk = await this.EncryptionConk({libraryId, objectId, writeToken});
    const data = await Crypto.Encrypt(conk, chunk);

    // Convert to ArrayBuffer
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }

  /**
   * Decrypt the specified chunk for the specified object or draft
   *
   * @methodGroup Encryption
   *
   * @namedParams
   * @param {string} libraryId - ID of the library
   * @param {string} objectId - ID of the object
   * @param {string} writeToken - Write token of the content object draft
   * @param {ArrayBuffer | Buffer} chunk - The data to decrypt
   *
   * @return {Promise&lt;ArrayBuffer>}
   */
  async Decrypt({libraryId, objectId, writeToken, chunk}) {
    ValidateParameters({libraryId, objectId});

    const conk = await this.EncryptionConk({libraryId, objectId, writeToken});
    const data = await Crypto.Decrypt(conk, chunk);

    // Convert to ArrayBuffer
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }

  /* Content Object Access */

  /**
   * Return the type of contract backing the specified ID
   *
   * @methodGroup Access Requests
   * @namedParams
   * @param {string} id - ID of the item
   *
   * @return {Promise&lt;string>} - Contract type of the item - "space", "library", "type", "object", "wallet", "group", or "other"
   */
  async AccessType({id}) {
    return await this.authClient.AccessType(id);
  }

  /**
   * Retrieve info about the access charge and permissions for the specified object.
   *
   * Note: Access charge is specified in ether
   *
   * @methodGroup Access Requests
   * @namedParams
   * @param {string} objectId - ID of the object
   * @param {object=} args - Arguments to the getAccessInfo method - See the base content contract
   *
   * @return {Promise&lt;Object>} - Info about the access charge and whether or not the object is accessible to the current user   */
  async AccessInfo({objectId, args}) {
    ValidateObject(objectId);

    if(!args) {
      args = [
        0, // Access level
        [], // Custom values
        [] // Stakeholders
      ];
    }

    this.Log(`Retrieving access info: ${objectId}`);

    const info = await this.ethClient.CallContractMethod({
      contractAddress: Utils.HashToAddress(objectId),
      abi: ContentContract.abi,
      methodName: "getAccessInfo",
      methodArgs: args,
      signer: this.signer
    });

    this.Log(info);

    return {
      visibilityCode: info[0],
      visible: info[0] >= 1,
      accessible: info[0] >= 10,
      editable: info[0] >= 100,
      hasAccess: info[1] === 0,
      accessCode: info[1],
      accessCharge: Utils.WeiToEther(info[2]).toString()
    };
  }

  /**
   * Make an explicit call to accessRequest or updateRequest of the appropriate contract. Unless noCache is specified on
   * this method or on the client, the resultant transaction hash of this method will be cached for all subsequent
   * access to this contract.
   *
   * Note: Access and update requests are handled automatically by ElvClient. Use this method only if you need to make
   * an explicit call. For example, if you need to specify custom arguments to access a content object, you can call
   * this method explicitly with those arguments. Since the result is cached (by default), all subsequent calls to
   * that content object will be authorized with that AccessRequest transaction.
   *
   * Note: If the access request has an associated charge, this charge will be determined and supplied automatically.
   *
   * @methodGroup Access Requests
   * @namedParams
   * @param {string=} libraryId - ID of the library
   * @param {string=} objectId - ID of the object
   * @param {string=} versionHash - Version hash of the object
   * @param {Array=} args=[] - Custom arguments to the accessRequest or updateRequest methods
   * @param {boolean=} update=false - If true, will call updateRequest instead of accessRequest
   * @param {boolean=} noCache=false - If true, the resultant transaction hash will not be cached for future use
   *
   * @return {Promise&lt;Object>} - Resultant AccessRequest or UpdateRequest event
   */
  async AccessRequest({libraryId, objectId, versionHash, args=[], update=false, noCache=false}) {
    ValidateParameters({libraryId, objectId, versionHash});

    if(versionHash) { objectId = this.utils.DecodeVersionHash(versionHash).objectId; }

    return await this.authClient.MakeAccessRequest({
      libraryId,
      objectId,
      versionHash,
      args,
      update,
      skipCache: true,
      noCache
    });
  }

  /**
   * Generate a state channel token.
   *
   * @methodGroup Access Requests
   * @namedParams
   * @param {string=} objectId - ID of the object
   * @param {string=} versionHash - Version hash of the object
   * @param {boolean=} noCache=false - If specified, a new state channel token will be generated
   * regardless whether or not one has been previously cached
   *
   * @return {Promise&lt;string>} - The state channel token
   */
  async GenerateStateChannelToken({objectId, versionHash, noCache=false}) {
    versionHash ? ValidateVersion(versionHash) : ValidateObject(objectId);

    if(versionHash) {
      objectId = this.utils.DecodeVersionHash(versionHash).objectId;
    } else if(!this.stateChannelAccess[objectId]) {
      versionHash = await this.LatestVersionHash({objectId});
    }

    this.stateChannelAccess[objectId] = versionHash;

    const audienceData = this.AudienceData({objectId, versionHash});

    return await this.authClient.AuthorizationToken({
      objectId,
      channelAuth: true,
      oauthToken: this.oauthToken,
      audienceData,
      noCache
    });
  }

  /**
   * Finalize state channel access
   *
   * @methodGroup Access Requests
   * @namedParams
   * @param {string=} objectId - ID of the object
   * @param {string=} versionHash - Version hash of the object
   * @param {number} percentComplete - Completion percentage of the content
   */
  async FinalizeStateChannelAccess({objectId, versionHash, percentComplete}) {
    versionHash ? ValidateVersion(versionHash) : ValidateObject(objectId);

    if(versionHash) {
      objectId = this.utils.DecodeVersionHash(versionHash).objectId;
    } else {
      if(this.stateChannelAccess[objectId]) {
        versionHash = this.stateChannelAccess[objectId];
      } else {
        versionHash = await this.LatestVersionHash({objectId});
      }
    }

    this.stateChannelAccess[objectId] = undefined;

    const audienceData = this.AudienceData({objectId, versionHash});

    await this.authClient.ChannelContentFinalize({
      objectId,
      audienceData,
      percent: percentComplete
    });
  }

  /**
   * Call accessComplete on the specified content object contract using a previously cached requestID.
   * Caching must be enabled and an access request must have been previously made on the specified
   * object by this client instance.
   *
   * @methodGroup Access Requests
   * @namedParams
   * @param {string} objectId - ID of the object
   * @param {number} score - Percentage score (0-100)
   *
   * @returns {Promise&lt;Object>} - Transaction log of the AccessComplete event
   */
  async ContentObjectAccessComplete({objectId, score=100}) {
    ValidateObject(objectId);

    if(score &lt; 0 || score > 100) { throw Error("Invalid AccessComplete score: " + score); }

    return await this.authClient.AccessComplete({id: objectId, abi: ContentContract.abi, score});
  }

  /* URL Methods */

  /**
   * Determine available DRM types available in this browser environment.
   *
   * @methodGroup Media
   * @return {Promise&lt;Array&lt;string>>}
   */
  async AvailableDRMs() {
    const availableDRMs = ["clear", "aes-128"];

    if(!window) {
      return availableDRMs;
    }

    if(typeof window.navigator.requestMediaKeySystemAccess !== "function") {
      return availableDRMs;
    }

    try {
      const config = [{
        initDataTypes: ["cenc"],
        audioCapabilities: [{
          contentType: "audio/mp4;codecs=\"mp4a.40.2\""
        }],
        videoCapabilities: [{
          contentType: "video/mp4;codecs=\"avc1.42E01E\""
        }]
      }];

      await navigator.requestMediaKeySystemAccess("com.widevine.alpha", config);

      availableDRMs.push("widevine");
    // eslint-disable-next-line no-empty
    } catch(e) {}

    return availableDRMs;
  }

  AudienceData({objectId, versionHash, protocols=[], drms=[]}) {
    versionHash ? ValidateVersion(versionHash) : ValidateObject(objectId);

    this.Log(`Retrieving audience data: ${objectId}`);

    let data = {
      user_address: this.utils.FormatAddress(this.signer.address),
      content_id: objectId || this.utils.DecodeVersionHash(versionHash).id,
      content_hash: versionHash,
      hostname: this.HttpClient.BaseURI().hostname(),
      access_time: Math.round(new Date().getTime()).toString(),
      format: protocols.join(","),
      drm: drms.join(",")
    };

    if(typeof window !== "undefined" &amp;&amp; window.navigator) {
      data.user_string = window.navigator.userAgent;
      data.language = window.navigator.language;
    }

    this.Log(data);

    return data;
  }

  /**
   * Retrieve playout options for the specified content that satisfy the given protocol and DRM requirements
   *
   * The root level playoutOptions[protocol].playoutUrl and playoutOptions[protocol].drms will contain playout
   * information that satisfies the specified DRM requirements (if possible), while playoutOptions[protocol].playoutMethods
   * will contain all available playout options for this content.
   *
   * If only objectId is specified, latest version will be played. To retrieve playout options for
   * a specific version of the content, provide the versionHash parameter (in which case objectId is unnecessary)
   *
   * @methodGroup Media
   * @namedParams
   * @param {string=} objectId - Id of the content
   * @param {string=} versionHash - Version hash of the content
   * @param {string=} linkPath - If playing from a link, the path to the link
   * @param {Array&lt;string>} protocols=["dash", "hls"] - Acceptable playout protocols ("dash", "hls")
   * @param {Array&lt;string>} drms - Acceptable DRM formats ("clear", "aes-128", "widevine")
   * @param {string=} offering=default - The offering to play
   */
  async PlayoutOptions({
    objectId,
    versionHash,
    linkPath,
    protocols=["dash", "hls"],
    offering="default",
    drms=[],
    hlsjsProfile=true
  }) {
    versionHash ? ValidateVersion(versionHash) : ValidateObject(objectId);

    protocols = protocols.map(p => p.toLowerCase());
    drms = drms.map(d => d.toLowerCase());

    if(!objectId) {
      objectId = this.utils.DecodeVersionHash(versionHash).objectId;
    }

    const libraryId = await this.ContentObjectLibraryId({objectId});

    let path, linkTargetLibraryId, linkTargetId, linkTargetHash;
    if(linkPath) {
      linkTargetHash = await this.LinkTarget({libraryId, objectId, versionHash, linkPath});
      linkTargetId = this.utils.DecodeVersionHash(linkTargetHash).objectId;
      linkTargetLibraryId = await this.ContentObjectLibraryId({objectId: linkTargetId});
      path = UrlJoin("q", versionHash || objectId, "meta", linkPath);
    } else {
      path = UrlJoin("q", versionHash || objectId, "rep", "playout", offering, "options.json");
    }

    const audienceData = this.AudienceData({
      objectId: linkTargetId || objectId,
      versionHash: linkTargetHash || versionHash || await this.LatestVersionHash({objectId}),
      protocols,
      drms
    });

    // Add authorization token to playout URLs
    let queryParams = {
      authorization: await this.authClient.AuthorizationToken({
        libraryId,
        objectId,
        channelAuth: true,
        oauthToken: this.oauthToken,
        audienceData
      })
    };

    if(linkPath) {
      queryParams.resolve = true;
    }

    const playoutOptions = Object.values(
      await this.utils.ResponseToJson(
        this.HttpClient.Request({
          path: path,
          method: "GET",
          queryParams
        })
      )
    );

    let playoutMap = {};
    for(let i = 0; i &lt; playoutOptions.length; i++) {
      const option = playoutOptions[i];
      const protocol = option.properties.protocol;
      const drm = option.properties.drm;
      // Remove authorization parameter from playout path - it's re-added by Rep
      const playoutPath = option.uri.split("?")[0];
      const licenseServers = option.properties.license_servers;

      // Create full playout URLs for this protocol / drm combo
      playoutMap[protocol] = {
        ...(playoutMap[protocol] || {}),
        playoutMethods: {
          ...((playoutMap[protocol] || {}).playoutMethods || {}),
          [drm || "clear"]: {
            playoutUrl: await this.Rep({
              libraryId: linkTargetLibraryId || libraryId,
              objectId: linkTargetId || objectId,
              versionHash: linkTargetHash || versionHash,
              rep: UrlJoin("playout", offering, playoutPath),
              channelAuth: true,
              queryParams: hlsjsProfile &amp;&amp; protocol === "hls" ? {player_profile: "hls-js"} : {}
            }),
            drms: drm ? {[drm]: {licenseServers}} : undefined
          }
        }
      };

      // Exclude any options that do not satisfy the specified protocols and/or DRMs
      const protocolMatch = protocols.includes(protocol);
      const drmMatch = drms.includes(drm || "clear") || (drms.length === 0 &amp;&amp; !drm);
      if(!protocolMatch || !drmMatch) {
        continue;
      }

      // This protocol / DRM satisfies the specifications (prefer DRM over clear, if available)
      if(!playoutMap[protocol].playoutUrl || (drm &amp;&amp; drm !== "clear")) {
        playoutMap[protocol].playoutUrl = playoutMap[protocol].playoutMethods[drm || "clear"].playoutUrl;
        playoutMap[protocol].drms = playoutMap[protocol].playoutMethods[drm || "clear"].drms;
      }
    }

    this.Log(playoutMap);

    return playoutMap;
  }

  /**
   * Retrieve playout options in BitMovin player format for the specified content that satisfy
   * the given protocol and DRM requirements
   *
   * If only objectId is specified, latest version will be played. To retrieve playout options for
   * a specific version of the content, provide the versionHash parameter (in which case objectId is unnecessary)
   *
   * @methodGroup Media
   * @namedParams
   * @param {string=} objectId - Id of the content
   * @param {string} versionHash - Version hash of the content
   * @param {string=} linkPath - If playing from a link, the path to the link
   * @param {Array&lt;string>} protocols=["dash", "hls"] - Acceptable playout protocols ("dash", "hls")
   * @param {Array&lt;string>} drms - Acceptable DRM formats ("clear", "aes-128", "widevine")
   * @param {string=} offering=default - The offering to play
   */
  async BitmovinPlayoutOptions({
    objectId,
    versionHash,
    linkPath,
    protocols=["dash", "hls"],
    drms=[],
    offering="default"
  }) {
    versionHash ? ValidateVersion(versionHash) : ValidateObject(objectId);

    if(!objectId) {
      objectId = this.utils.DecodeVersionHash(versionHash).objectId;
    }

    const playoutOptions = await this.PlayoutOptions({
      objectId,
      versionHash,
      linkPath,
      protocols,
      drms,
      offering,
      hlsjsProfile: false
    });

    delete playoutOptions.playoutMethods;

    let config = {
      drm: {}
    };

    const authToken = await this.authClient.AuthorizationToken({
      objectId,
      channelAuth: true,
      oauthToken: this.oauthToken
    });

    Object.keys(playoutOptions).forEach(protocol => {
      const option = playoutOptions[protocol];
      config[protocol] = option.playoutUrl;

      if(option.drms) {
        Object.keys(option.drms).forEach(drm => {
          // No license URL specified
          if(!option.drms[drm].licenseServers || option.drms[drm].licenseServers.length === 0) { return; }

          // Opt for https urls
          const filterHTTPS = uri => uri.toLowerCase().startsWith("https");
          let licenseUrls = option.drms[drm].licenseServers;
          if(licenseUrls.find(filterHTTPS)) {
            licenseUrls = licenseUrls.filter(filterHTTPS);
          }

          // Choose a random license server from the available list
          const licenseUrl = licenseUrls.sort(() => 0.5 - Math.random())[0];

          if(!config.drm[drm]) {
            config.drm[drm] = {
              LA_URL: licenseUrl,
              headers: {
                Authorization: `Bearer ${authToken}`
              }
            };
          }
        });
      }
    });

    return config;
  }

  /**
   * Call the specified bitcode method on the specified object
   *
   * @methodGroup URL Generation
   * @namedParams
   * @param {string=} libraryId - ID of the library
   * @param {string=} objectId - ID of the object
   * @param {string=} versionHash - Hash of the object version - if not specified, latest version will be used
   * @param {string=} writeToken - Write token of an object draft - if calling bitcode of a draft object
   * @param {string} method - Bitcode method to call
   * @param {Object=} queryParams - Query parameters to include in the request
   * @param {Object=} body - Request body to include, if calling a non-constant method
   * @param {Object=} headers - Request headers to include
   * @param {boolean=} constant=true - If specified, a GET request authenticated with an AccessRequest will be made.
   * Otherwise, a POST with an UpdateRequest will be performed
   * @param {string=} format=json - The format of the response
   *
   * @returns {Promise&lt;format>} - The response from the call in the specified format
   */
  async CallBitcodeMethod({
    libraryId,
    objectId,
    versionHash,
    writeToken,
    method,
    queryParams={},
    body={},
    headers={},
    constant=true,
    format="json"
  }) {
    ValidateParameters({libraryId, objectId, versionHash});
    if(!method) { throw "Bitcode method not specified"; }

    if(versionHash) { objectId = this.utils.DecodeVersionHash(versionHash).objectId; }

    let path = UrlJoin("q", writeToken || versionHash || objectId, "call", method);

    if(libraryId) {
      path = UrlJoin("qlibs", libraryId, path);
    }

    let authHeader = headers.authorization || headers.Authorization;
    if(!authHeader) {
      headers.Authorization = (
        await this.authClient.AuthorizationHeader({
          libraryId,
          objectId,
          update: !constant
        })
      ).Authorization;
    }

    this.Log(
      `Calling bitcode method: ${libraryId || ""} ${objectId || versionHash} ${writeToken || ""}
      ${constant ? "GET" : "POST"} ${path}
      Query Params:
      ${queryParams}
      Body:
      ${body}
      Headers
      ${headers}`
    );

    return this.utils.ResponseToFormat(
      format,
      await this.HttpClient.Request({
        body,
        headers,
        method: constant ? "GET" : "POST",
        path,
        queryParams,
        failover: false
      })
    );
  }

  /**
   * Generate a URL to the specified /rep endpoint of a content object. URL includes authorization token.
   *
   * Alias for the FabricUrl method with the "rep" parameter
   *
   * @methodGroup URL Generation
   * @namedParams
   * @param {string=} libraryId - ID of the library
   * @param {string=} objectId - ID of the object
   * @param {string=} versionHash - Hash of the object version - if not specified, latest version will be used
   * @param {string} rep - Representation to use
   * @param {Object=} queryParams - Query params to add to the URL
   * @param {boolean=} channelAuth=false - If specified, state channel authorization will be performed instead of access request authorization
   * @param {boolean=} noAuth=false - If specified, authorization will not be performed and the URL will not have an authorization
   * token. This is useful for accessing public assets.
   * @param {boolean=} noCache=false - If specified, a new access request will be made for the authorization regardless of
   * whether such a request exists in the client cache. This request will not be cached. This option has no effect if noAuth is true.
   *
   * @see &lt;a href="#FabricUrl">FabricUrl&lt;/a> for creating arbitrary fabric URLs
   *
   * @returns {Promise&lt;string>} - URL to the specified rep endpoint with authorization token
   */
  async Rep({libraryId, objectId, versionHash, rep, queryParams={}, channelAuth=false, noAuth=false, noCache=false}) {
    ValidateParameters({libraryId, objectId, versionHash});
    if(!rep) { throw "Rep not specified"; }

    return this.FabricUrl({libraryId, objectId, versionHash, rep, queryParams, channelAuth, noAuth, noCache});
  }

  /**
   * Generate a URL to the specified /public endpoint of a content object. URL includes authorization token.
   *
   * Alias for the FabricUrl method with the "rep" parameter
   *
   * @methodGroup URL Generation
   * @namedParams
   * @param {string=} libraryId - ID of the library
   * @param {string=} objectId - ID of the object
   * @param {string=} versionHash - Hash of the object version - if not specified, latest version will be used
   * @param {string} rep - Representation to use
   * @param {Object=} queryParams - Query params to add to the URL
   *
   * @see &lt;a href="#FabricUrl">FabricUrl&lt;/a> for creating arbitrary fabric URLs
   *
   * @returns {Promise&lt;string>} - URL to the specified rep endpoint with authorization token
   */
  async PublicRep({libraryId, objectId, versionHash, rep, queryParams={}}) {
    ValidateParameters({libraryId, objectId, versionHash});
    if(!rep) { throw "Rep not specified"; }

    return this.FabricUrl({libraryId, objectId, versionHash, publicRep: rep, queryParams, noAuth: true});
  }

  /**
   * Generate a URL to the specified item in the content fabric with appropriate authorization token.
   *
   * @methodGroup URL Generation
   * @namedParams
   * @param {string=} libraryId - ID of an library
   * @param {string=} objectId - ID of an object
   * @param {string=} versionHash - Hash of an object version
   * @param {string=} writeToken - A write token for a draft of the object (requires libraryId)
   * @param {string=} partHash - Hash of a part - Requires object ID
   * @param {string=} rep - Rep parameter of the url
   * @param {string=} publicRep - Public rep parameter of the url
   * @param {string=} call - Bitcode method to call
   * @param {Object=} queryParams - Query params to add to the URL
   * @param {boolean=} channelAuth=false - If specified, state channel authorization will be used instead of access request authorization
   * @param {boolean=} noAuth=false - If specified, authorization will not be performed and the URL will not have an authorization
   * token. This is useful for accessing public assets.
   * @param {boolean=} noCache=false - If specified, a new access request will be made for the authorization regardless of
   * whether such a request exists in the client cache. This request will not be cached. This option has no effect if noAuth is true.
   *
   * @returns {Promise&lt;string>} - URL to the specified endpoint with authorization token
   */
  async FabricUrl({
    libraryId,
    objectId,
    versionHash,
    writeToken,
    partHash,
    rep,
    publicRep,
    call,
    queryParams={},
    channelAuth=false,
    noAuth=false,
    noCache=false
  }) {
    if(objectId || versionHash) {
      ValidateParameters({libraryId, objectId, versionHash});
    }

    if(versionHash) { objectId = this.utils.DecodeVersionHash(versionHash).objectId; }

    this.Log(
      `Building Fabric URL:
      libraryId: ${libraryId}
      objectId: ${objectId}
      versionHash: ${versionHash}
      writeToken: ${writeToken}
      partHash: ${partHash}
      rep: ${rep}
      publicRep: ${publicRep}
      call: ${call}
      channelAuth: ${channelAuth}
      noAuth: ${noAuth}
      noCache: ${noCache}
      queryParams: ${JSON.stringify(queryParams || {}, null, 2)}`
    );

    // Clone queryParams to avoid modification of the original
    queryParams = {...queryParams};

    queryParams.authorization = await this.authClient.AuthorizationToken({libraryId, objectId, versionHash, channelAuth, noAuth, noCache});

    let path = "";
    if(libraryId) {
      path = UrlJoin(path, "qlibs", libraryId);

      if(objectId || versionHash) {
        path = UrlJoin(path, "q", writeToken || versionHash || objectId);
      }
    } else if(versionHash) {
      path = UrlJoin("q", versionHash);
    }

    if(partHash){
      path = UrlJoin(path, "data", partHash);
    } else if(rep) {
      path = UrlJoin(path, "rep", rep);
    } else if(publicRep) {
      path = UrlJoin(path, "public", publicRep);
    } else if(call) {
      path = UrlJoin(path, "call", call);
    }

    return this.HttpClient.URL({
      path,
      queryParams
    });
  }

  /**
   * Generate a URL to the specified content object file with appropriate authorization token.
   *
   * @methodGroup URL Generation
   * @namedParams
   * @param {string=} libraryId - ID of an library
   * @param {string=} objectId - ID of an object
   * @param {string=} versionHash - Hash of an object version
   * @param {string=} writeToken - A write token for a draft of the object (requires libraryId)
   * @param {string} filePath - Path to the content object file
   * @param {Object=} queryParams - Query params to add to the URL
   * @param {boolean=} noCache=false - If specified, a new access request will be made for the authorization regardless of
   * whether such a request exists in the client cache. This request will not be cached.
   *
   * @returns {Promise&lt;string>} - URL to the specified file with authorization token
   */
  async FileUrl({libraryId, objectId, versionHash, writeToken, filePath, queryParams={}, noCache=false}) {
    ValidateParameters({libraryId, objectId, versionHash});
    if(!filePath) { throw "File path not specified"; }

    if(versionHash) { objectId = this.utils.DecodeVersionHash(versionHash).objectId; }

    let path;

    if(libraryId) {
      path = UrlJoin("qlibs", libraryId, "q", writeToken || versionHash || objectId, "files", filePath);
    } else {
      path = UrlJoin("q", versionHash, "files", filePath);
    }

    const authorizationToken = await this.authClient.AuthorizationToken({libraryId, objectId, noCache});

    return this.HttpClient.URL({
      path: path,
      queryParams: {
        ...queryParams,
        authorization: authorizationToken
      }
    });
  }

  /* Links */

  /**
   * Get a specific content object in the library
   *
   * @methodGroup Links
   * @namedParams
   * @param {string=} libraryId - ID of the library
   * @param {string=} objectId - ID of the object
   * @param {string=} versionHash - Version hash of the object -- if not specified, latest version is returned
   * @param {boolean=} autoUpdate=false - If true, lists only links marked as auto-update links
   * @param {(string | Array&lt;string>)=} select - Limit metadata fields return in link details
   *
   * @returns {Promise&lt;Object>} - Description of created object
   */
  async ContentObjectGraph({libraryId, objectId, versionHash, autoUpdate=false, select}) {
    ValidateParameters({libraryId, objectId, versionHash});

    this.Log(`Retrieving content object graph: ${libraryId || ""} ${objectId || versionHash}`);

    if(versionHash) { objectId = this.utils.DecodeVersionHash(versionHash).objectId; }

    let path = UrlJoin("q", versionHash || objectId, "links");

    try {
      return await this.utils.ResponseToJson(
        this.HttpClient.Request({
          headers: await this.authClient.AuthorizationHeader({libraryId, objectId, versionHash, noAuth: true}),
          queryParams: {
            auto_update: autoUpdate,
            select
          },
          method: "GET",
          path: path
        })
      );
    } catch(error) {
      // If a cycle is present, do some work to present useful information about it
      let errorInfo;
      try {
        const cycles = error.body.errors[0].cause.cause.cause.cycle;

        if(!cycles || cycles.length === 0) { throw error; }

        let info = {};
        await Promise.all(
          cycles.map(async cycleHash => {
            if(info[cycleHash]) { return; }

            const cycleId = (this.utils.DecodeVersionHash(cycleHash)).objectId;
            const name = (
              await this.ContentObjectMetadata({versionHash: cycleHash, metadataSubtree: "public/asset_metadata/display_title"}) ||
              await this.ContentObjectMetadata({versionHash: cycleHash, metadataSubtree: "public/name"}) ||
              await this.ContentObjectMetadata({versionHash: cycleHash, metadataSubtree: "name"}) ||
              cycleId
            );

            info[cycleHash] = { name, objectId: cycleId };
          })
        );

        errorInfo = cycles.map(cycleHash => `${info[cycleHash].name} (${info[cycleHash].objectId})`);
      } catch(e) {
        throw error;
      }

      throw new Error(
        `Cycle found in links: ${errorInfo.join(" -> ")}`
      );
    }
  }

  /**
   * Retrieve the version hash of the specified link's target. If the target is the same as the specified
   * object and versionHash is not specified, will return the latest version hash.
   *
   * @methodGroup Links
   * @namedParams
   * @param {string=} libraryId - ID of an library
   * @param {string=} objectId - ID of an object
   * @param {string=} versionHash - Hash of an object version
   * @param {string} linkPath - Path to the content object link
   *
   * @returns {Promise&lt;string>} - Version hash of the link's target
   */
  async LinkTarget({libraryId, objectId, versionHash, linkPath}) {
    if(versionHash) { objectId = this.utils.DecodeVersionHash(versionHash).objectId; }

    const linkInfo = await this.ContentObjectMetadata({
      libraryId,
      objectId,
      versionHash,
      metadataSubtree: UrlJoin(linkPath),
      resolveLinks: false
    });

    if(!linkInfo || !linkInfo["/"]) {
      throw Error(`No valid link at ${linkPath}`);
    }

    /* For absolute links - extract the hash from the link itself. Otherwise use "container" */
    let targetHash = ((linkInfo["/"] || "").match(/^\/?qfab\/([\w]+)\/?.+/) || [])[1];
    if(!targetHash) {
      targetHash = linkInfo["."].container;
    }

    if(targetHash) {
      return targetHash;
    } else if(versionHash) {
      return versionHash;
    }

    // Link points to this object - get latest version
    if(!libraryId) {
      libraryId = await this.ContentObjectLibraryId({objectId});
    }

    return (await this.ContentObject({libraryId, objectId})).hash;
  }

  /**
   * Generate a URL to the specified file link with appropriate authentication
   *
   * @methodGroup Links
   * @namedParams
   * @param {string=} libraryId - ID of an library
   * @param {string=} objectId - ID of an object
   * @param {string=} versionHash - Hash of an object version
   * @param {string} linkPath - Path to the content object link
   * @param {string=} mimeType - Mime type to use when rendering the file
   * @param {Object=} queryParams - Query params to add to the URL
   * @param {boolean=} noCache=false - If specified, a new access request will be made for the authorization regardless of
   * whether such a request exists in the client cache. This request will not be cached.
   *
   * @returns {Promise&lt;string>} - URL to the specified file with authorization token
   */
  async LinkUrl({libraryId, objectId, versionHash, linkPath, mimeType, queryParams={}, noCache=false}) {
    ValidateParameters({libraryId, objectId, versionHash});

    if(!linkPath) { throw Error("Link path not specified"); }

    if(versionHash) { objectId = this.utils.DecodeVersionHash(versionHash).objectId; }

    let path;
    if(libraryId) {
      path = UrlJoin("qlibs", libraryId, "q", versionHash || objectId, "meta", linkPath);
    } else {
      path = UrlJoin("q", versionHash, "meta", linkPath);
    }

    queryParams = {
      ...queryParams,
      resolve: true,
      authorization: await this.authClient.AuthorizationToken({libraryId, objectId, noCache, noAuth: true})
    };

    if(mimeType) { queryParams["header-accept"] = mimeType; }

    return this.HttpClient.URL({
      path: path,
      queryParams
    });
  }

  /**
   * Retrieve the data at the specified link in the specified format
   *
   * @methodGroup Links
   * @namedParams
   * @param {string=} libraryId - ID of an library
   * @param {string=} objectId - ID of an object
   * @param {string=} versionHash - Hash of an object version
   * @param {string} linkPath - Path to the content object link
   * @param {string=} format=json - Format of the response
   */
  async LinkData({libraryId, objectId, versionHash, linkPath, format="json"}) {
    const linkUrl = await this.LinkUrl({libraryId, objectId, versionHash, linkPath});

    return this.utils.ResponseToFormat(
      format,
      await HttpClient.Fetch(linkUrl)
    );
  }

  /* Collection */

  /**
   * Get a list of unique addresses of all of the specified type the current user has access
   * to through both their user wallet and through access groups
   *
   * @methodGroup Collections
   * @namedParams
   * @param {string} collectionType - Type of collection to retrieve
   * - accessGroups
   * - contentObjects
   * - contentTypes
   * - contracts
   * - libraries
   *
   * @return {Promise&lt;Array&lt;string>>} - List of addresses of available items
   */
  async Collection({collectionType}) {
    const validCollectionTypes = [
      "accessGroups",
      "contentObjects",
      "contentTypes",
      "contracts",
      "libraries"
    ];

    if(!validCollectionTypes.includes(collectionType)) {
      throw new Error("Invalid collection type: " + collectionType);
    }

    const walletAddress = this.signer ? await this.userProfileClient.WalletAddress() : undefined;
    if(!walletAddress) {
      throw new Error("Unable to get collection: User wallet doesn't exist");
    }

    this.Log(`Retrieving ${collectionType} contract collection for user ${this.signer.address}`);

    return await this.ethClient.MakeProviderCall({
      methodName: "send",
      args: [
        "elv_getWalletCollection",
        [
          this.contentSpaceId,
          `iusr${this.utils.AddressToHash(this.signer.address)}`,
          collectionType
        ]
      ]
    });
  }

  /* Verification */

  /**
   * Verify the specified content object
   *
   * @methodGroup Content Objects
   * @namedParams
   * @param {string} libraryId - ID of the library
   * @param {string} objectId - ID of the object
   * @param {string} versionHash - Hash of the content object version
   *
   * @returns {Promise&lt;Object>} - Response describing verification results
   */
  async VerifyContentObject({libraryId, objectId, versionHash}) {
    ValidateParameters({libraryId, objectId, versionHash});

    return await ContentObjectVerification.VerifyContentObject({
      client: this,
      libraryId,
      objectId,
      versionHash
    });
  }

  /**
   * Get the proofs associated with a given part
   *
   * @methodGroup Content Objects
   * @namedParams
   * @param {string=} libraryId - ID of the library
   * @param {string=} objectId - ID of the object
   * @param {string=} versionHash - Hash of the object version - If not specified, latest version will be used
   * @param {string} partHash - Hash of the part
   *
   * @returns {Promise&lt;Object>} - Response containing proof information
   */
  async Proofs({libraryId, objectId, versionHash, partHash}) {
    ValidateParameters({libraryId, objectId, versionHash});
    ValidatePartHash(partHash);

    if(versionHash) { objectId = this.utils.DecodeVersionHash(versionHash).objectId; }

    let path = UrlJoin("q", versionHash || objectId, "data", partHash, "proofs");

    return this.utils.ResponseToJson(
      this.HttpClient.Request({
        headers: await this.authClient.AuthorizationHeader({libraryId, objectId, versionHash}),
        method: "GET",
        path: path
      })
    );
  }

  /**
   * Get part info in CBOR format
   *
   * @methodGroup Content Objects
   * @namedParams
   * @param {string} libraryId - ID of the library - required for authentication
   * @param {string} objectId - ID of the object - required for authentication
   * @param {string} partHash - Hash of the part
   * @param {string} format - Format to retrieve the response - defaults to Blob
   *
   * @returns {Promise&lt;Format>} - Response containing the CBOR response in the specified format
   */
  async QParts({libraryId, objectId, partHash, format="blob"}) {
    ValidateParameters({libraryId, objectId, versionHash});
    ValidatePartHash(partHash);

    let path = UrlJoin("qparts", partHash);

    return this.utils.ResponseToFormat(
      format,
      this.HttpClient.Request({
        headers: await this.authClient.AuthorizationHeader({libraryId, objectId, partHash}),
        method: "GET",
        path: path
      })
    );
  }

  /* FrameClient related */

  // Whitelist of methods allowed to be called using the frame API
  FrameAllowedMethods() {
    const forbiddenMethods = [
      "constructor",
      "AccessGroupMembershipMethod",
      "CallFromFrameMessage",
      "ClearSigner",
      "FormatBlockNumbers",
      "FrameAllowedMethods",
      "FromConfigurationUrl",
      "GenerateWallet",
      "InitializeClients",
      "Log",
      "SetSigner",
      "SetSignerFromWeb3Provider",
      "ToggleLogging"
    ];

    return Object.getOwnPropertyNames(Object.getPrototypeOf(this))
      .filter(method => !forbiddenMethods.includes(method));
  }

  // Call a method specified in a message from a frame
  async CallFromFrameMessage(message, Respond) {
    if(message.type !== "ElvFrameRequest") { return; }

    let callback;
    if(message.callbackId) {
      callback = (result) => {
        Respond(this.utils.MakeClonable({
          type: "ElvFrameResponse",
          requestId: message.callbackId,
          response: result
        }));
      };

      message.args.callback = callback;
    }

    try {
      const method = message.calledMethod;

      let methodResults;
      if(message.module === "userProfileClient") {
        if(!this.userProfileClient.FrameAllowedMethods().includes(method)) {
          throw Error("Invalid user profile method: " + method);
        }

        methodResults = await this.userProfileClient[method](message.args);
      } else {
        if(!this.FrameAllowedMethods().includes(method)) {
          throw Error("Invalid method: " + method);
        }

        methodResults = await this[method](message.args);
      }

      Respond(this.utils.MakeClonable({
        type: "ElvFrameResponse",
        requestId: message.requestId,
        response: methodResults
      }));
    } catch(error) {
      // eslint-disable-next-line no-console
      this.Log(
        `Frame Message Error:
        Method: ${message.calledMethod}
        Arguments: ${JSON.stringify(message.args, null, 2)}
        Error: ${typeof error === "object" ? JSON.stringify(error, null, 2) : error}`,
        true
      );

      // eslint-disable-next-line no-console
      console.error(error);

      const responseError = error instanceof Error ? error.message : error;
      Respond(this.utils.MakeClonable({
        type: "ElvFrameResponse",
        requestId: message.requestId,
        error: responseError
      }));
    }
  }
}

Object.assign(ElvClient.prototype, require("./client/ABRPublishing"));
Object.assign(ElvClient.prototype, require("./client/AccessGroups").access);
Object.assign(ElvClient.prototype, require("./client/AccessGroups").manage);
Object.assign(ElvClient.prototype, require("./client/Contracts"));
Object.assign(ElvClient.prototype, require("./client/Files").access);
Object.assign(ElvClient.prototype, require("./client/Files").manage);

const AccessClient = Object.assign(ElvClient, {});

const ManagementClient = Object.assign(ElvClient, {});
Object.assign(ManagementClient.prototype, require("./client/Management"));

exports.AccessClient = AccessClient;
exports.ElvClient = ManagementClient;


</code></pre>
</div>

    



        <footer class="footer">
          Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a>
        </footer>
      </div>
    </div>
  </div>

  <script>
    // Format and add line numbers to code
    prettyPrint();
  </script>

  <script type="text/javascript" src="scripts/utils.js"></script>

  </body>
</html>
